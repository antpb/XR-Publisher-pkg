import type { Armature, Bone, Pose } from '../../armature/index';
import { Transform } from '../../maths';
import { vec3 } from 'gl-matrix';
declare class IKLink {
    idx: number;
    pidx: number;
    len: number;
    bind: Transform;
    effectorDir: vec3;
    poleDir: vec3;
    constructor(idx: number, len: number);
    static fromBone(b: Bone): IKLink;
}
declare class IKChain {
    links: IKLink[];
    solver: any;
    /** How many bones in the chain */
    count: number;
    /** Total Length of the Chain */
    length: number;
    constructor(bName?: string[], arm?: Armature);
    addBone(b: Bone): this;
    setBones(bNames: string[], arm: Armature): this;
    setSolver(s: any): this;
    bindToPose(pose: Pose): this;
    /** For usecase when bone lengths have been recomputed for a pose which differs from the initial armature */
    resetLengths(pose: Pose): void;
    first(): IKLink;
    last(): IKLink;
    getEndPositions(pose: Pose): Array<vec3>;
    getPositionAt(pose: Pose, idx: number): vec3;
    getAllPositions(pose: Pose): Array<vec3>;
    getStartPosition(pose: Pose): vec3;
    getMiddlePosition(pose: Pose): vec3;
    getLastPosition(pose: Pose): vec3;
    getTailPosition(pose: Pose, ignoreScale?: boolean): vec3;
    getAltDirections(pose: Pose, idx?: number): Array<vec3>;
    bindAltDirections(pose: Pose, effectorDir: vec3, poleDir: vec3): this;
    setAltDirections(effectorDir: vec3, poleDir: vec3): this;
    resolveToPose(pose: Pose, debug?: any): this;
}
export { IKChain, IKLink };
