var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Maths {
  static mod(a, b) {
    const v = a % b;
    return v < 0 ? b + v : v;
  }
}
class FrameInfo {
  constructor() {
    __publicField(this, "kt0", 0);
    __publicField(this, "kt1", 0);
    __publicField(this, "k0", -1);
    __publicField(this, "k1", -1);
    __publicField(this, "t", 0);
    __publicField(this, "ti", 0);
  }
}
class Animator {
  constructor() {
    __publicField(this, "frameInfo", []);
    __publicField(this, "clock", 0);
    __publicField(this, "clip");
    __publicField(this, "inPlace", false);
  }
  resetClock() {
    this.clock = 0;
    return this;
  }
  setClip(c) {
    this.clip = c;
    return this;
  }
  update(deltaTime) {
    this.clock = (this.clock + deltaTime) % this.clip.duration;
    this._computeFrameInfo();
    return this;
  }
  applyPose(pose) {
    if (!this.clip)
      return this;
    let t;
    for (t of this.clip.tracks) {
      t.apply(pose, this.frameInfo[t.timeStampIndex]);
    }
    if (this.inPlace) {
      const bPos = pose.bones[0].local.pos;
      bPos[1] = 0;
    }
    return this;
  }
  atKey(n) {
    if (!this.clip)
      return this;
    if (n < 0)
      n = 0;
    this._genFrameInfo();
    const aryTs = this.clip.timeStamps;
    const aryFi = this.frameInfo;
    let ts;
    let fi;
    let tsLen;
    for (let i = 0; i < aryTs.length; i++) {
      ts = aryTs[i];
      fi = aryFi[i];
      tsLen = ts.length - 1;
      fi.t = 1;
      fi.ti = 0;
      fi.k0 = n <= tsLen ? n : tsLen;
      fi.k1 = fi.k0;
      fi.kt0 = fi.k0;
      fi.kt1 = fi.k0;
    }
    return this;
  }
  _genFrameInfo() {
    const aryFi = this.frameInfo;
    const aryTs = this.clip.timeStamps;
    if (aryFi.length < aryTs.length) {
      for (let i = aryFi.length; i < aryTs.length; i++)
        aryFi.push(new FrameInfo());
    }
  }
  _computeFrameInfo() {
    if (!this.clip)
      return;
    this._genFrameInfo();
    const aryFi = this.frameInfo;
    const aryTs = this.clip.timeStamps;
    const time = this.clock;
    let ts;
    let fi;
    let tLen;
    for (let i = 0; i < aryTs.length; i++) {
      ts = aryTs[i];
      fi = aryFi[i];
      tLen = ts.length;
      if (tLen == 0) {
        fi.t = 1;
        fi.ti = 0;
        fi.k0 = 0;
        fi.k1 = 0;
        fi.kt0 = 0;
        fi.kt1 = 0;
        continue;
      }
      if (fi.k0 != -1 && time >= ts[fi.k0] && time <= ts[fi.k1])
        ;
      else {
        let imin = 0, mi = 0, imax = ts.length - 1;
        while (imin < imax) {
          mi = imin + imax >>> 1;
          if (time < ts[mi])
            imax = mi;
          else
            imin = mi + 1;
        }
        if (imax <= 0) {
          fi.k0 = 0;
          fi.k1 = 1;
        } else {
          fi.k0 = imax - 1;
          fi.k1 = imax;
        }
        fi.kt0 = Maths.mod(fi.k0 - 1, tLen);
        fi.kt1 = Maths.mod(fi.k1 + 1, tLen);
      }
      fi.t = (time - ts[fi.k0]) / (ts[fi.k1] - ts[fi.k0]);
      fi.ti = 1 - fi.t;
    }
  }
}
const ELerp$1 = {
  Step: 0,
  Linear: 1,
  Cubic: 2
};
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create$5() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function create$4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone$1(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function invert$2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply$3(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
var mul$3 = multiply$3;
function create$3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy$2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set$2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply$2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale2) {
  out[0] = a[0] + b[0] * scale2;
  out[1] = a[1] + b[1] * scale2;
  out[2] = a[2] + b[2] * scale2;
  return out;
}
function squaredLength$3(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  out[2] = a[2] * len2;
  return out;
}
function dot$2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
var sub = subtract;
var mul$2 = multiply$2;
var len = length;
var sqrLen = squaredLength$3;
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function copy$1(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set$1(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function squaredLength$2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function normalize$1(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
function dot$1(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
(function() {
  var vec = create$2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$1() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply$1(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert$1(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot2 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot2 ? 1 / dot2 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var copy = copy$1;
var set = set$1;
var mul$1 = multiply$1;
var dot = dot$1;
var squaredLength$1 = squaredLength$2;
var normalize = normalize$1;
var rotationTo = function() {
  var tmpvec3 = create$3();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a, b) {
    var dot2 = dot$2(a, b);
    if (dot2 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize$2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot2 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot2;
      return normalize(out, out);
    }
  };
}();
(function() {
  var temp1 = create$1();
  var temp2 = create$1();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$5();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
})();
function create() {
  var dq = new ARRAY_TYPE(8);
  if (ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}
function clone(a) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
function multiply(out, a, b) {
  var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
var mul = multiply;
function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
var squaredLength = squaredLength$1;
class TypePool {
  static vec3() {
    let v = this._vec3Pool.pop();
    if (!v)
      v = create$3();
    return v;
  }
  static quat() {
    let v = this._quatPool.pop();
    if (!v)
      v = create$1();
    return v;
  }
  static recycle_vec3(...ary) {
    let v;
    for (v of ary)
      this._vec3Pool.push(set$2(v, 0, 0, 0));
    return this;
  }
  static recycle_quat(...ary) {
    let v;
    for (v of ary)
      this._quatPool.push(set(v, 0, 0, 0, 1));
    return this;
  }
}
__publicField(TypePool, "_vec3Pool", []);
__publicField(TypePool, "_quatPool", []);
class Transform {
  constructor(rot, pos, scl) {
    __publicField(this, "rot", create$1());
    __publicField(this, "pos", create$3());
    __publicField(this, "scl", fromValues(1, 1, 1));
    if (rot instanceof Transform) {
      this.copy(rot);
    } else if (rot && pos && scl) {
      this.set(rot, pos, scl);
    }
  }
  reset() {
    set(this.rot, 0, 0, 0, 1);
    set$2(this.pos, 0, 0, 0);
    set$2(this.scl, 1, 1, 1);
    return this;
  }
  copy(t) {
    copy(this.rot, t.rot);
    copy$2(this.pos, t.pos);
    copy$2(this.scl, t.scl);
    return this;
  }
  set(r, p, s) {
    if (r)
      copy(this.rot, r);
    if (p)
      copy$2(this.pos, p);
    if (s)
      copy$2(this.scl, s);
    return this;
  }
  setPos(v) {
    copy$2(this.pos, v);
    return this;
  }
  setRot(v) {
    copy(this.rot, v);
    return this;
  }
  setScl(v) {
    copy$2(this.scl, v);
    return this;
  }
  setUniformScale(v) {
    this.scl[0] = v;
    this.scl[1] = v;
    this.scl[2] = v;
    return this;
  }
  clone() {
    return new Transform(this);
  }
  mul(cr, cp, cs) {
    if (cr instanceof Transform) {
      cp = cr.pos;
      cs = cr.scl;
      cr = cr.rot;
    }
    if (cr && cp) {
      const tmp = [0, 0, 0];
      mul$2(tmp, this.scl, cp);
      transformQuat(tmp, tmp, this.rot);
      add(this.pos, this.pos, tmp);
      if (cs)
        mul$2(this.scl, this.scl, cs);
      mul$1(this.rot, this.rot, cr);
    }
    return this;
  }
  pmul(pr, pp, ps) {
    if (pr instanceof Transform) {
      pp = pr.pos;
      ps = pr.scl;
      pr = pr.rot;
    }
    if (!pr || !pp || !ps)
      return this;
    const tmp = [0, 0, 0];
    mul$2(tmp, this.pos, ps);
    transformQuat(tmp, tmp, pr);
    add(this.pos, tmp, pp);
    if (ps)
      mul$2(this.scl, this.scl, ps);
    mul$1(this.rot, pr, this.rot);
    return this;
  }
  addPos(cp, ignoreScl = false) {
    if (ignoreScl) {
      add(this.pos, this.pos, transformQuat([0, 0, 0], cp, this.rot));
    } else {
      const tmp = [0, 0, 0];
      mul$2(tmp, cp, this.scl);
      add(this.pos, this.pos, transformQuat(tmp, tmp, this.rot));
    }
    return this;
  }
  fromMul(tp, tc) {
    const tmp = [0, 0, 0];
    mul$2(tmp, tp.scl, tc.pos);
    transformQuat(tmp, tmp, tp.rot);
    add(this.pos, tp.pos, tmp);
    mul$2(this.scl, tp.scl, tc.scl);
    mul$1(this.rot, tp.rot, tc.rot);
    return this;
  }
  fromInvert(t) {
    invert$1(this.rot, t.rot);
    inverse(this.scl, t.scl);
    const tmp = [0, 0, 0];
    negate(tmp, t.pos);
    mul$2(tmp, tmp, this.scl);
    transformQuat(this.pos, tmp, this.rot);
    return this;
  }
  transformVec3(v, out) {
    const tmp = [0, 0, 0];
    mul$2(tmp, v, this.scl);
    transformQuat(tmp, tmp, this.rot);
    return add(out || v, tmp, this.pos);
  }
  static mul(tp, tc) {
    return new Transform().fromMul(tp, tc);
  }
  static invert(t) {
    return new Transform().fromInvert(t);
  }
  static fromPos(x, y, z) {
    const t = new Transform();
    if (x instanceof Float32Array || x instanceof Array) {
      copy$2(t.pos, x);
    } else if (x != void 0 && y != void 0 && z != void 0) {
      set$2(t.pos, x, y, z);
    }
    return t;
  }
}
class DualQuatUtil {
  static fromBuf(out, ary, idx) {
    out[0] = ary[idx];
    out[1] = ary[idx + 1];
    out[2] = ary[idx + 2];
    out[3] = ary[idx + 3];
    out[4] = ary[idx + 4];
    out[5] = ary[idx + 5];
    out[6] = ary[idx + 6];
    out[7] = ary[idx + 7];
    return out;
  }
  static toBuf(m, ary, idx) {
    ary[idx] = m[0];
    ary[idx + 1] = m[1];
    ary[idx + 2] = m[2];
    ary[idx + 3] = m[3];
    ary[idx + 4] = m[4];
    ary[idx + 5] = m[5];
    ary[idx + 6] = m[6];
    ary[idx + 7] = m[7];
    return this;
  }
}
class Mat4Util {
  static fromBuf(out, ary, idx) {
    out[0] = ary[idx];
    out[1] = ary[idx + 1];
    out[2] = ary[idx + 2];
    out[3] = ary[idx + 3];
    out[4] = ary[idx + 4];
    out[5] = ary[idx + 5];
    out[6] = ary[idx + 6];
    out[7] = ary[idx + 7];
    out[8] = ary[idx + 8];
    out[9] = ary[idx + 9];
    out[10] = ary[idx + 10];
    out[11] = ary[idx + 11];
    out[12] = ary[idx + 12];
    out[13] = ary[idx + 13];
    out[14] = ary[idx + 14];
    out[15] = ary[idx + 15];
    return out;
  }
  static toBuf(m, ary, idx) {
    ary[idx] = m[0];
    ary[idx + 1] = m[1];
    ary[idx + 2] = m[2];
    ary[idx + 3] = m[3];
    ary[idx + 4] = m[4];
    ary[idx + 5] = m[5];
    ary[idx + 6] = m[6];
    ary[idx + 7] = m[7];
    ary[idx + 8] = m[8];
    ary[idx + 9] = m[9];
    ary[idx + 10] = m[10];
    ary[idx + 11] = m[11];
    ary[idx + 12] = m[12];
    ary[idx + 13] = m[13];
    ary[idx + 14] = m[14];
    ary[idx + 15] = m[15];
    return this;
  }
}
class QuatUtil {
  static fromBuf(out, ary, idx) {
    out[0] = ary[idx];
    out[1] = ary[idx + 1];
    out[2] = ary[idx + 2];
    out[3] = ary[idx + 3];
    return out;
  }
  static toBuf(q, ary, idx) {
    ary[idx] = q[0];
    ary[idx + 1] = q[1];
    ary[idx + 2] = q[2];
    ary[idx + 3] = q[3];
    return this;
  }
  static lenSqr(a, b) {
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2 + (a[3] - b[3]) ** 2;
  }
  static isZero(q) {
    return q[0] == 0 && q[1] == 0 && q[2] == 0 && q[3] == 0;
  }
  static negate(out, q) {
    if (!q)
      q = out;
    out[0] = -q[0];
    out[1] = -q[1];
    out[2] = -q[2];
    out[3] = -q[3];
    return out;
  }
  static dotNegate(out, chg, chk) {
    if (dot(chg, chk) < 0)
      this.negate(out, chg);
    return out;
  }
  static pmulAxisAngle(out, axis, angle, q) {
    const half = angle * 0.5, s = Math.sin(half), ax = axis[0] * s, ay = axis[1] * s, az = axis[2] * s, aw = Math.cos(half), bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  static pmulInvert(out, q, qinv) {
    let ax = qinv[0], ay = qinv[1], az = qinv[2], aw = qinv[3];
    const dot2 = ax * ax + ay * ay + az * az + aw * aw;
    if (dot2 == 0) {
      ax = ay = az = aw = 0;
    } else {
      const dot_inv = 1 / dot2;
      ax = -ax * dot_inv;
      ay = -ay * dot_inv;
      az = -az * dot_inv;
      aw = aw * dot_inv;
    }
    const bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  static nblend(out, a, b, t) {
    const a_x = a[0], a_y = a[1], a_z = a[2], a_w = a[3], b_x = b[0], b_y = b[1], b_z = b[2], b_w = b[3], dot2 = a_x * b_x + a_y * b_y + a_z * b_z + a_w * b_w, ti = 1 - t;
    let s = 1;
    if (dot2 < 0)
      s = -1;
    out[0] = ti * a_x + t * b_x * s;
    out[1] = ti * a_y + t * b_y * s;
    out[2] = ti * a_z + t * b_z * s;
    out[3] = ti * a_w + t * b_w * s;
    return normalize(out, out);
  }
}
class Vec3Util {
  static len(a, b) {
    return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2);
  }
  static lenSqr(a, b) {
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2;
  }
  static isZero(v) {
    return v[0] == 0 && v[1] == 0 && v[2] == 0;
  }
  static nearZero(out, v) {
    out[0] = Math.abs(v[0]) <= 1e-6 ? 0 : v[0];
    out[1] = Math.abs(v[1]) <= 1e-6 ? 0 : v[1];
    out[2] = Math.abs(v[2]) <= 1e-6 ? 0 : v[2];
    return out;
  }
  static fromBuf(out, ary, idx) {
    out[0] = ary[idx];
    out[1] = ary[idx + 1];
    out[2] = ary[idx + 2];
    return out;
  }
  static toBuf(v, ary, idx) {
    ary[idx] = v[0];
    ary[idx + 1] = v[1];
    ary[idx + 2] = v[2];
    return this;
  }
  static toStruct(v, o) {
    o != null ? o : o = { x: 0, y: 0, z: 0 };
    o.x = v[0];
    o.y = v[1];
    o.z = v[2];
    return o;
  }
  static fromStruct(v, o) {
    v[0] = o.x;
    v[1] = o.y;
    v[2] = o.z;
    return v;
  }
  static toArray(v) {
    return [v[0], v[1], v[2]];
  }
}
class Vec4Util {
  static fromBuf(out, ary, idx) {
    out[0] = ary[idx];
    out[1] = ary[idx + 1];
    out[2] = ary[idx + 2];
    return out;
  }
  static toBuf(v, ary, idx) {
    ary[idx] = v[0];
    ary[idx + 1] = v[1];
    ary[idx + 2] = v[2];
    return this;
  }
}
function vec3_step(track, fi, out) {
  return Vec3Util.fromBuf(out, track.values, fi.k0 * 3);
}
function vec3_linear(track, fi, out) {
  const v0 = TypePool.vec3();
  const v1 = TypePool.vec3();
  Vec3Util.fromBuf(v0, track.values, fi.k0 * 3);
  Vec3Util.fromBuf(v1, track.values, fi.k1 * 3);
  lerp(out, v0, v1, fi.t);
  TypePool.recycle_vec3(v0, v1);
  return out;
}
class Vec3Track {
  constructor() {
    __publicField(this, "name", "Vec3Track");
    __publicField(this, "values");
    __publicField(this, "boneIndex", -1);
    __publicField(this, "timeStampIndex", -1);
    __publicField(this, "fnLerp", vec3_linear);
  }
  setInterpolation(i) {
    switch (i) {
      case ELerp$1.Step:
        this.fnLerp = vec3_step;
        break;
      case ELerp$1.Linear:
        this.fnLerp = vec3_linear;
        break;
      case ELerp$1.Cubic:
        console.warn("Vec3 Cubic Lerp Not Implemented");
        break;
    }
    return this;
  }
  apply(pose, fi) {
    const v = TypePool.vec3();
    pose.setLocalPos(this.boneIndex, this.fnLerp(this, fi, v));
    TypePool.recycle_vec3(v);
    return this;
  }
}
function quat_step(track, fi, out) {
  return QuatUtil.fromBuf(out, track.values, fi.k0 * 4);
}
function quat_linear(track, fi, out) {
  const v0 = TypePool.quat();
  const v1 = TypePool.quat();
  QuatUtil.fromBuf(v0, track.values, fi.k0 * 4);
  QuatUtil.fromBuf(v1, track.values, fi.k1 * 4);
  QuatUtil.nblend(out, v0, v1, fi.t);
  TypePool.recycle_quat(v0, v1);
  return out;
}
class QuatTrack {
  constructor() {
    __publicField(this, "name", "QuatTrack");
    __publicField(this, "values");
    __publicField(this, "boneIndex", -1);
    __publicField(this, "timeStampIndex", -1);
    __publicField(this, "fnLerp", quat_linear);
  }
  setInterpolation(i) {
    switch (i) {
      case ELerp$1.Step:
        this.fnLerp = quat_step;
        break;
      case ELerp$1.Linear:
        this.fnLerp = quat_linear;
        break;
      case ELerp$1.Cubic:
        console.warn("Quat Cubic Lerp Not Implemented");
        break;
    }
    return this;
  }
  apply(pose, fi) {
    const q = TypePool.quat();
    pose.setLocalRot(this.boneIndex, this.fnLerp(this, fi, q));
    TypePool.recycle_quat(q);
    return this;
  }
}
class Clip {
  constructor() {
    __publicField(this, "name", "");
    __publicField(this, "frameCount", 0);
    __publicField(this, "duration", 0);
    __publicField(this, "tracks", []);
    __publicField(this, "timeStamps", []);
  }
  static fromGLTF2(anim) {
    const clip = new Clip();
    clip.name = anim.name;
    let i;
    for (i of anim.timestamps) {
      if (i.data)
        clip.timeStamps.push(new Float32Array(i.data));
      if (i.elementCnt > clip.frameCount)
        clip.frameCount = i.elementCnt;
      if (i.boundMax && i.boundMax[0] > clip.duration)
        clip.duration = i.boundMax[0];
    }
    let t;
    let track;
    for (t of anim.tracks) {
      if (t.transform == 1 && t.jointIndex != 0)
        continue;
      switch (t.transform) {
        case 0:
          track = new QuatTrack();
          break;
        case 1:
          track = new Vec3Track();
          break;
        case 2:
          continue;
        default:
          console.error("unknown animation track transform", t.transform);
          continue;
      }
      switch (t.interpolation) {
        case 0:
          track.setInterpolation(ELerp$1.Step);
          break;
        case 1:
          track.setInterpolation(ELerp$1.Linear);
          break;
        case 2:
          track.setInterpolation(ELerp$1.Cubic);
          break;
      }
      if (t.keyframes.data)
        track.values = new Float32Array(t.keyframes.data);
      else
        console.error("Track has no keyframe data");
      track.timeStampIndex = t.timeStampIndex;
      track.boneIndex = t.jointIndex;
      clip.tracks.push(track);
    }
    return clip;
  }
}
class BoneParse {
  constructor(name, isLR, reFind, reExclude, isChain = false) {
    __publicField(this, "name");
    __publicField(this, "isLR");
    __publicField(this, "isChain");
    __publicField(this, "reFind");
    __publicField(this, "reExclude");
    this.name = name;
    this.isLR = isLR;
    this.isChain = isChain;
    this.reFind = new RegExp(reFind, "i");
    if (reExclude)
      this.reExclude = new RegExp(reExclude, "i");
  }
  test(bname) {
    if (!this.reFind.test(bname))
      return null;
    if (this.reExclude && this.reExclude.test(bname))
      return null;
    if (this.isLR && reLeft.test(bname))
      return this.name + "_l";
    if (this.isLR && reRight.test(bname))
      return this.name + "_r";
    return this.name;
  }
}
const reLeft = new RegExp("\\.l|left|_l", "i");
const reRight = new RegExp("\\.r|right|_r", "i");
const Parsers = [
  new BoneParse("thigh", true, "thigh|up.*leg", "twist"),
  new BoneParse("shin", true, "shin|leg|calf", "up|twist"),
  new BoneParse("foot", true, "foot"),
  new BoneParse("shoulder", true, "clavicle|shoulder"),
  new BoneParse("upperarm", true, "(upper.*arm|arm)", "fore|twist|lower"),
  new BoneParse("forearm", true, "forearm|arm", "up|twist"),
  new BoneParse("hand", true, "hand", "thumb|index|middle|ring|pinky"),
  new BoneParse("head", false, "head"),
  new BoneParse("neck", false, "neck"),
  new BoneParse("hip", false, "hips*|pelvis"),
  new BoneParse("spine", false, "spine.*d*|chest", void 0, true)
];
class BoneChain {
  constructor() {
    __publicField(this, "items", []);
  }
}
class BoneInfo {
  constructor(idx, name) {
    __publicField(this, "index");
    __publicField(this, "name");
    this.index = idx;
    this.name = name;
  }
}
class BoneMap {
  constructor(arm) {
    __publicField(this, "bones", /* @__PURE__ */ new Map());
    let i;
    let b;
    let bp;
    let key;
    for (i = 0; i < arm.bones.length; i++) {
      b = arm.bones[i];
      for (bp of Parsers) {
        if (!(key = bp.test(b.name)))
          continue;
        if (!this.bones.has(key)) {
          if (bp.isChain) {
            const ch = new BoneChain();
            ch.items.push(new BoneInfo(i, b.name));
            this.bones.set(key, ch);
          } else {
            this.bones.set(key, new BoneInfo(i, b.name));
          }
        } else {
          if (bp.isChain) {
            const ch = this.bones.get(bp.name);
            if (ch && ch instanceof BoneChain)
              ch.items.push(new BoneInfo(i, b.name));
          }
        }
        break;
      }
    }
  }
}
class Source {
  constructor(arm) {
    __publicField(this, "arm");
    __publicField(this, "pose");
    __publicField(this, "posHip", create$3());
    this.arm = arm;
    this.pose = arm.newPose();
  }
}
class BoneLink {
  constructor(fIdx, fName, tIdx, tName) {
    __publicField(this, "fromIndex");
    __publicField(this, "fromName");
    __publicField(this, "toIndex");
    __publicField(this, "toName");
    __publicField(this, "quatFromParent", create$1());
    __publicField(this, "quatDotCheck", create$1());
    __publicField(this, "wquatFromTo", create$1());
    __publicField(this, "toWorldLocal", create$1());
    this.fromIndex = fIdx;
    this.fromName = fName;
    this.toIndex = tIdx;
    this.toName = tName;
  }
  bind(fromTPose, toTPose) {
    const fBone = fromTPose.bones[this.fromIndex];
    const tBone = toTPose.bones[this.toIndex];
    copy(this.quatFromParent, fBone.pidx != -1 ? fromTPose.bones[fBone.pidx].world.rot : fromTPose.offset.rot);
    if (tBone.pidx != -1)
      invert$1(this.toWorldLocal, toTPose.bones[tBone.pidx].world.rot);
    else
      invert$1(this.toWorldLocal, toTPose.offset.rot);
    invert$1(this.wquatFromTo, fBone.world.rot);
    mul$1(this.wquatFromTo, this.wquatFromTo, tBone.world.rot);
    copy(this.quatDotCheck, fBone.world.rot);
    return this;
  }
}
class Retarget {
  constructor() {
    __publicField(this, "hipScale", 1);
    __publicField(this, "anim", new Animator());
    __publicField(this, "map", /* @__PURE__ */ new Map());
    __publicField(this, "from");
    __publicField(this, "to");
  }
  setClip(c) {
    this.anim.setClip(c);
    return this;
  }
  setClipArmature(arm) {
    this.from = new Source(arm);
    return this;
  }
  setClipPoseOffset(rot, pos, scl) {
    const p = this.from.pose;
    if (rot)
      copy(p.offset.rot, rot);
    if (pos)
      copy$2(p.offset.pos, pos);
    if (scl)
      copy$2(p.offset.scl, scl);
    return this;
  }
  setTargetArmature(arm) {
    this.to = new Source(arm);
    return this;
  }
  getClipPose(doUpdate = false, incOffset = false) {
    if (doUpdate)
      this.from.pose.updateWorld(incOffset);
    return this.from.pose;
  }
  getTargetPose(doUpdate = false, incOffset = false) {
    if (doUpdate)
      this.to.pose.updateWorld(incOffset);
    return this.to.pose;
  }
  bind() {
    const mapFrom = new BoneMap(this.from.arm);
    const mapTo = new BoneMap(this.to.arm);
    this.from.pose.updateWorld(true);
    this.to.pose.updateWorld(true);
    let i, fLen, tLen, len2, lnk, k, bFrom, bTo;
    for ([k, bFrom] of mapFrom.bones) {
      bTo = mapTo.bones.get(k);
      if (!bTo) {
        console.warn("Target missing bone :", k);
        continue;
      }
      if (bFrom instanceof BoneInfo && bTo instanceof BoneInfo) {
        lnk = new BoneLink(bFrom.index, bFrom.name, bTo.index, bTo.name);
        lnk.bind(this.from.pose, this.to.pose);
        this.map.set(k, lnk);
      } else if (bFrom instanceof BoneChain && bTo instanceof BoneChain) {
        fLen = bFrom.items.length;
        tLen = bTo.items.length;
        if (fLen == 1 && tLen == 1) {
          this.map.set(k, new BoneLink(bFrom.items[0].index, bFrom.items[0].name, bTo.items[0].index, bTo.items[0].name).bind(this.from.pose, this.to.pose));
        } else if (fLen >= 2 && tLen >= 2) {
          this.map.set(k + "_0", new BoneLink(bFrom.items[0].index, bFrom.items[0].name, bTo.items[0].index, bTo.items[0].name).bind(this.from.pose, this.to.pose));
          this.map.set(k + "_x", new BoneLink(bFrom.items[fLen - 1].index, bFrom.items[fLen - 1].name, bTo.items[tLen - 1].index, bTo.items[tLen - 1].name).bind(this.from.pose, this.to.pose));
          for (i = 1; i < Math.min(fLen - 1, tLen - 1); i++) {
            lnk = new BoneLink(bFrom.items[i].index, bFrom.items[i].name, bTo.items[i].index, bTo.items[i].name);
            lnk.bind(this.from.pose, this.to.pose);
            this.map.set(k + "_" + i, lnk);
          }
        } else {
          len2 = Math.min(bFrom.items.length, bTo.items.length);
          for (i = 0; i < len2; i++) {
            lnk = new BoneLink(bFrom.items[i].index, bFrom.items[i].name, bTo.items[i].index, bTo.items[i].name);
            lnk.bind(this.from.pose, this.to.pose);
            this.map.set(k + "_" + i, lnk);
          }
        }
      } else {
        console.warn("Bone Mapping is mix match of info and chain", k);
      }
    }
    const hip = this.map.get("hip");
    if (hip) {
      const fBone = this.from.pose.bones[hip.fromIndex];
      const tBone = this.to.pose.bones[hip.toIndex];
      Vec3Util.nearZero(this.from.posHip, fBone.world.pos);
      Vec3Util.nearZero(this.to.posHip, tBone.world.pos);
      this.hipScale = Math.abs(this.to.posHip[1] / this.from.posHip[1]);
    }
    return true;
  }
  animateNext(dt) {
    this.anim.update(dt).applyPose(this.from.pose);
    this.from.pose.updateWorld(true);
    this.applyRetarget();
    this.to.pose.updateWorld(true);
    return this;
  }
  atKey(k) {
    this.anim.atKey(k).applyPose(this.from.pose);
    this.from.pose.updateWorld(true);
    this.applyRetarget();
    this.to.pose.updateWorld(true);
    return this;
  }
  applyRetarget() {
    const fPose = this.from.pose.bones;
    const tPose = this.to.pose.bones;
    const diff = create$1();
    const tmp = create$1();
    let fBone;
    let tBone;
    let bl;
    for (bl of this.map.values()) {
      fBone = fPose[bl.fromIndex];
      tBone = tPose[bl.toIndex];
      mul$1(diff, bl.quatFromParent, fBone.local.rot);
      if (dot(diff, bl.quatDotCheck) < 0) {
        QuatUtil.negate(tmp, bl.wquatFromTo);
        mul$1(diff, diff, tmp);
      } else {
        mul$1(diff, diff, bl.wquatFromTo);
      }
      mul$1(diff, bl.toWorldLocal, diff);
      copy(tBone.local.rot, diff);
    }
    const hip = this.map.get("hip");
    if (hip) {
      const fBone2 = this.from.pose.bones[hip.fromIndex];
      const tBone2 = this.to.pose.bones[hip.toIndex];
      const v = create$3();
      sub(v, fBone2.world.pos, this.from.posHip);
      scale(v, v, this.hipScale);
      add(v, v, this.to.posHip);
      copy$2(tBone2.local.pos, v);
    }
  }
}
class Bone {
  constructor(name, idx, len2 = 0) {
    __publicField(this, "name");
    __publicField(this, "idx");
    __publicField(this, "pidx");
    __publicField(this, "len");
    __publicField(this, "local", new Transform());
    __publicField(this, "world", new Transform());
    this.name = name;
    this.idx = idx;
    this.pidx = -1;
    this.len = len2;
  }
  setLocal(rot, pos, scl) {
    if (rot)
      copy(this.local.rot, rot);
    if (pos)
      copy$2(this.local.pos, pos);
    if (scl)
      copy$2(this.local.scl, scl);
    return this;
  }
  clone() {
    const b = new Bone(this.name, this.idx, this.len);
    b.pidx = this.pidx;
    b.local.copy(this.local);
    b.world.copy(this.world);
    return b;
  }
}
class Pose$1 {
  constructor(arm) {
    __publicField(this, "arm");
    __publicField(this, "bones");
    __publicField(this, "offset", new Transform());
    if (arm) {
      const bCnt = arm.bones.length;
      this.bones = new Array(bCnt);
      this.arm = arm;
      for (let i = 0; i < bCnt; i++) {
        this.bones[i] = arm.bones[i].clone();
      }
      this.offset.copy(this.arm.offset);
    }
  }
  get(bName) {
    const bIdx = this.arm.names.get(bName);
    return bIdx !== void 0 ? this.bones[bIdx] : null;
  }
  clone() {
    const bCnt = this.bones.length;
    const p = new Pose$1();
    p.arm = this.arm;
    p.bones = new Array(bCnt);
    p.offset.copy(this.offset);
    for (let i = 0; i < bCnt; i++) {
      p.bones[i] = this.bones[i].clone();
    }
    return p;
  }
  setLocalPos(bone, v) {
    const bIdx = typeof bone === "string" ? this.arm.names.get(bone) : bone;
    if (bIdx != void 0)
      copy$2(this.bones[bIdx].local.pos, v);
    return this;
  }
  setLocalRot(bone, v) {
    const bIdx = typeof bone === "string" ? this.arm.names.get(bone) : bone;
    if (bIdx != void 0)
      copy(this.bones[bIdx].local.rot, v);
    return this;
  }
  fromGLTF2(glPose) {
    let jnt;
    let b;
    for (jnt of glPose.joints) {
      b = this.bones[jnt.index];
      if (jnt.rot)
        copy(b.local.rot, jnt.rot);
      if (jnt.pos)
        copy$2(b.local.pos, jnt.pos);
      if (jnt.scl)
        copy$2(b.local.scl, jnt.scl);
    }
    return this;
  }
  copy(pose) {
    const bLen = this.bones.length;
    for (let i = 0; i < bLen; i++) {
      this.bones[i].local.copy(pose.bones[i].local);
      this.bones[i].world.copy(pose.bones[i].world);
    }
    return this;
  }
  rotLocal(bone, deg, axis = "x") {
    const bIdx = typeof bone === "string" ? this.arm.names.get(bone) : bone;
    if (bIdx != void 0) {
      const q = this.bones[bIdx].local.rot;
      const rad = deg * Math.PI / 180;
      switch (axis) {
        case "y":
          rotateY(q, q, rad);
          break;
        case "z":
          rotateZ(q, q, rad);
          break;
        default:
          rotateX(q, q, rad);
          break;
      }
    } else
      console.warn("Bone not found, ", bone);
    return this;
  }
  rotWorld(bone, deg, axis = "x") {
    const bIdx = typeof bone === "string" ? this.arm.names.get(bone) : bone;
    if (bIdx != void 0) {
      const ax = axis == "y" ? [0, 1, 0] : axis == "z" ? [0, 0, 1] : [1, 0, 0];
      const b = this.bones[bIdx];
      const p = this.getWorldRotation(b.pidx, [0, 0, 0, 1]);
      const q = mul$1([0, 0, 0, 1], p, b.local.rot);
      const rad = deg * Math.PI / 180;
      const rot = setAxisAngle([0, 0, 0, 1], ax, rad);
      mul$1(q, rot, q);
      QuatUtil.pmulInvert(b.local.rot, q, p);
    } else
      console.warn("Bone not found, ", bone);
    return this;
  }
  moveLocal(bone, offset) {
    const bIdx = typeof bone === "string" ? this.arm.names.get(bone) : bone;
    if (bIdx != void 0) {
      const v = this.bones[bIdx].local.pos;
      add(v, v, offset);
    } else
      console.warn("Bone not found, ", bone);
    return this;
  }
  sclLocal(bone, v) {
    const bIdx = typeof bone === "string" ? this.arm.names.get(bone) : bone;
    if (bIdx != void 0) {
      const scl = this.bones[bIdx].local.scl;
      if (v instanceof Array || v instanceof Float32Array)
        copy$2(scl, v);
      else
        set$2(scl, v, v, v);
    } else
      console.warn("Bone not found, ", bone);
    return this;
  }
  updateWorld(useOffset = true) {
    let i, b;
    for (i = 0; i < this.bones.length; i++) {
      b = this.bones[i];
      if (b.pidx != -1)
        b.world.fromMul(this.bones[b.pidx].world, b.local);
      else if (useOffset)
        b.world.fromMul(this.offset, b.local);
      else
        b.world.copy(b.local);
    }
    return this;
  }
  getWorldTransform(bIdx, out) {
    out != null ? out : out = new Transform();
    if (bIdx == -1)
      return out.copy(this.offset);
    let bone = this.bones[bIdx];
    out.copy(bone.local);
    while (bone.pidx != -1) {
      bone = this.bones[bone.pidx];
      out.pmul(bone.local);
    }
    out.pmul(this.offset);
    return out;
  }
  getWorldRotation(bIdx, out) {
    out != null ? out : out = create$1();
    if (bIdx == -1) {
      copy(out, this.offset.rot);
      return out;
    }
    let bone = this.bones[bIdx];
    copy(out, bone.local.rot);
    while (bone.pidx != -1) {
      bone = this.bones[bone.pidx];
      mul$1(out, bone.local.rot, out);
    }
    mul$1(out, this.offset.rot, out);
    return out;
  }
  updateBoneLengths(defaultBoneLen = 0) {
    const bCnt = this.bones.length;
    let b, p;
    let i;
    if (defaultBoneLen != 0) {
      for (b of this.bones)
        b.len = 0;
    }
    for (i = bCnt - 1; i >= 0; i--) {
      b = this.bones[i];
      if (b.pidx == -1)
        continue;
      p = this.bones[b.pidx];
      p.len = Vec3Util.len(p.world.pos, b.world.pos);
    }
    if (defaultBoneLen != 0) {
      for (i = 0; i < bCnt; i++) {
        b = this.bones[i];
        if (b.len == 0)
          b.len = defaultBoneLen;
      }
    }
    return this;
  }
}
class Armature {
  constructor() {
    __publicField(this, "names", /* @__PURE__ */ new Map());
    __publicField(this, "bones", []);
    __publicField(this, "skin");
    __publicField(this, "offset", new Transform());
  }
  addBone(name, pidx, rot, pos, scl) {
    const idx = this.bones.length;
    const bone = new Bone(name, idx);
    this.bones.push(bone);
    this.names.set(name, idx);
    if (pos || rot || scl)
      bone.setLocal(rot, pos, scl);
    if (pidx != null && pidx != void 0 && pidx != -1)
      bone.pidx = pidx;
    return bone;
  }
  bind(skin, defaultBoneLen = 1) {
    this.updateWorld();
    this.updateBoneLengths(defaultBoneLen);
    if (skin)
      this.skin = new skin().init(this);
    return this;
  }
  clone() {
    var _a;
    const arm = new Armature();
    arm.skin = (_a = this.skin) == null ? void 0 : _a.clone();
    arm.offset.copy(this.offset);
    this.bones.forEach((b) => arm.bones.push(b.clone()));
    this.names.forEach((v, k) => arm.names.set(k, v));
    return arm;
  }
  newPose(doWorldUpdate = false) {
    const p = new Pose$1(this);
    return doWorldUpdate ? p.updateWorld() : p;
  }
  getBone(bName) {
    const idx = this.names.get(bName);
    if (idx == void 0)
      return null;
    return this.bones[idx];
  }
  getSkinOffsets() {
    return this.skin ? this.skin.getOffsets() : null;
  }
  updateSkinFromPose(pose) {
    if (this.skin) {
      this.skin.updateFromPose(pose);
      return this.skin.getOffsets();
    }
    return null;
  }
  updateWorld() {
    const bCnt = this.bones.length;
    let b;
    for (let i = 0; i < bCnt; i++) {
      b = this.bones[i];
      if (b.pidx != -1)
        b.world.fromMul(this.bones[b.pidx].world, b.local);
      else
        b.world.copy(b.local);
    }
    return this;
  }
  updateBoneLengths(defaultBoneLen = 0) {
    const bCnt = this.bones.length;
    let b;
    let p;
    for (let i = bCnt - 1; i >= 0; i--) {
      b = this.bones[i];
      if (b.pidx == -1)
        continue;
      p = this.bones[b.pidx];
      p.len = Vec3Util.len(p.world.pos, b.world.pos);
    }
    if (defaultBoneLen != 0) {
      for (let i = 0; i < bCnt; i++) {
        b = this.bones[i];
        if (b.len == 0)
          b.len = defaultBoneLen;
      }
    }
    return this;
  }
}
const COMP_LEN$2 = 16;
const BYTE_LEN$2 = COMP_LEN$2 * 4;
class SkinMTX {
  constructor() {
    __publicField(this, "bind");
    __publicField(this, "world");
    __publicField(this, "offsetBuffer");
  }
  init(arm) {
    const mat4Identity = create$4();
    const bCnt = arm.bones.length;
    const world = new Array(bCnt);
    const bind = new Array(bCnt);
    this.offsetBuffer = new Float32Array(16 * bCnt);
    for (let i = 0; i < bCnt; i++) {
      world[i] = create$4();
      bind[i] = create$4();
    }
    let b, l, m;
    for (let i = 0; i < bCnt; i++) {
      b = arm.bones[i];
      l = b.local;
      m = world[i];
      fromRotationTranslationScale(m, l.rot, l.pos, l.scl);
      if (b.pidx != -1)
        mul$3(m, world[b.pidx], m);
      invert$2(bind[i], m);
      Mat4Util.toBuf(mat4Identity, this.offsetBuffer, i * 16);
    }
    this.bind = bind;
    this.world = world;
    return this;
  }
  updateFromPose(pose) {
    const offset = create$4();
    fromRotationTranslationScale(offset, pose.offset.rot, pose.offset.pos, pose.offset.scl);
    const bOffset = create$4();
    let b;
    let m;
    let i;
    for (i = 0; i < pose.bones.length; i++) {
      b = pose.bones[i];
      m = this.world[i];
      fromRotationTranslationScale(m, b.local.rot, b.local.pos, b.local.scl);
      if (b.pidx != -1)
        mul$3(m, this.world[b.pidx], m);
      else
        mul$3(m, offset, m);
      mul$3(bOffset, m, this.bind[i]);
      Mat4Util.toBuf(bOffset, this.offsetBuffer, i * 16);
    }
    return this;
  }
  getOffsets() {
    return [this.offsetBuffer];
  }
  getTextureInfo(frameCount) {
    const boneCount = this.bind.length;
    const strideFloatLength = COMP_LEN$2;
    const strideByteLength = BYTE_LEN$2;
    const pixelsPerStride = COMP_LEN$2 / 4;
    const floatRowSize = COMP_LEN$2 * frameCount;
    const bufferFloatSize = floatRowSize * boneCount;
    const bufferByteSize = bufferFloatSize * 4;
    const pixelWidth = pixelsPerStride * frameCount;
    const pixelHeight = boneCount;
    const o = {
      boneCount,
      strideFloatLength,
      strideByteLength,
      pixelsPerStride,
      floatRowSize,
      bufferFloatSize,
      bufferByteSize,
      pixelWidth,
      pixelHeight
    };
    return o;
  }
  clone() {
    const skin = new SkinMTX();
    skin.offsetBuffer = new Float32Array(this.offsetBuffer);
    skin.bind = this.bind.map((v) => clone$1(v));
    skin.world = this.world.map((v) => clone$1(v));
    return skin;
  }
}
const COMP_LEN$1 = 8;
const BYTE_LEN$1 = COMP_LEN$1 * 4;
class SkinDQ {
  constructor() {
    __publicField(this, "bind");
    __publicField(this, "world");
    __publicField(this, "offsetQBuffer");
    __publicField(this, "offsetPBuffer");
  }
  init(arm) {
    const bCnt = arm.bones.length;
    const world = new Array(bCnt);
    const bind = new Array(bCnt);
    this.offsetQBuffer = new Float32Array(4 * bCnt);
    this.offsetPBuffer = new Float32Array(4 * bCnt);
    for (let i = 0; i < bCnt; i++) {
      world[i] = create();
      bind[i] = create();
    }
    let l;
    let b;
    let q;
    for (let i = 0; i < bCnt; i++) {
      b = arm.bones[i];
      l = b.local;
      q = world[i];
      fromRotationTranslation(q, l.rot, l.pos);
      if (b.pidx != -1)
        mul(q, world[b.pidx], q);
      invert(bind[i], q);
      Vec4Util.toBuf([0, 0, 0, 1], this.offsetQBuffer, i * 4);
      Vec4Util.toBuf([0, 0, 0, 0], this.offsetPBuffer, i * 4);
    }
    this.bind = bind;
    this.world = world;
    return this;
  }
  updateFromPose(pose) {
    const offset = create();
    fromRotationTranslation(offset, pose.offset.rot, pose.offset.pos);
    const bOffset = create();
    let b;
    let q;
    let i;
    let ii;
    for (i = 0; i < pose.bones.length; i++) {
      b = pose.bones[i];
      q = this.world[i];
      fromRotationTranslation(q, b.local.rot, b.local.pos);
      if (b.pidx != -1)
        mul(q, this.world[b.pidx], q);
      else
        mul(q, offset, q);
      mul(bOffset, q, this.bind[i]);
      ii = i * 4;
      this.offsetQBuffer[ii + 0] = bOffset[0];
      this.offsetQBuffer[ii + 1] = bOffset[1];
      this.offsetQBuffer[ii + 2] = bOffset[2];
      this.offsetQBuffer[ii + 3] = bOffset[3];
      this.offsetPBuffer[ii + 0] = bOffset[4];
      this.offsetPBuffer[ii + 1] = bOffset[5];
      this.offsetPBuffer[ii + 2] = bOffset[6];
      this.offsetPBuffer[ii + 3] = bOffset[7];
    }
    return this;
  }
  getOffsets() {
    return [this.offsetQBuffer, this.offsetPBuffer];
  }
  getTextureInfo(frameCount) {
    const boneCount = this.bind.length;
    const strideByteLength = BYTE_LEN$1;
    const strideFloatLength = COMP_LEN$1;
    const pixelsPerStride = COMP_LEN$1 / 4;
    const floatRowSize = COMP_LEN$1 * frameCount;
    const bufferFloatSize = floatRowSize * boneCount;
    const bufferByteSize = bufferFloatSize * 4;
    const pixelWidth = pixelsPerStride * frameCount;
    const pixelHeight = boneCount;
    const o = {
      boneCount,
      strideByteLength,
      strideFloatLength,
      pixelsPerStride,
      floatRowSize,
      bufferFloatSize,
      bufferByteSize,
      pixelWidth,
      pixelHeight
    };
    return o;
  }
  clone() {
    const skin = new SkinDQ();
    skin.offsetQBuffer = new Float32Array(this.offsetQBuffer);
    skin.offsetPBuffer = new Float32Array(this.offsetPBuffer);
    skin.bind = this.bind.map((v) => clone(v));
    skin.world = this.world.map((v) => clone(v));
    return skin;
  }
}
const COMP_LEN = 12;
const BYTE_LEN = COMP_LEN * 4;
class SkinDQT {
  constructor() {
    __publicField(this, "bind");
    __publicField(this, "world");
    __publicField(this, "offsetQBuffer");
    __publicField(this, "offsetPBuffer");
    __publicField(this, "offsetSBuffer");
  }
  init(arm) {
    const bCnt = arm.bones.length;
    const world = new Array(bCnt);
    const bind = new Array(bCnt);
    this.offsetQBuffer = new Float32Array(4 * bCnt);
    this.offsetPBuffer = new Float32Array(4 * bCnt);
    this.offsetSBuffer = new Float32Array(3 * bCnt);
    for (let i = 0; i < bCnt; i++) {
      world[i] = new Transform();
      bind[i] = new Transform();
    }
    let b;
    let t;
    for (let i = 0; i < bCnt; i++) {
      b = arm.bones[i];
      t = world[i];
      t.copy(b.local);
      if (b.pidx != -1)
        t.pmul(world[b.pidx]);
      bind[i].fromInvert(t);
      Vec4Util.toBuf([0, 0, 0, 1], this.offsetQBuffer, i * 4);
      Vec4Util.toBuf([0, 0, 0, 0], this.offsetPBuffer, i * 4);
      Vec3Util.toBuf([1, 1, 1], this.offsetSBuffer, i * 3);
    }
    this.bind = bind;
    this.world = world;
    return this;
  }
  updateFromPose(pose) {
    const offset = pose.offset;
    const bOffset = new Transform();
    const dq = create();
    let b;
    let ws;
    let i;
    let ii;
    let si;
    for (i = 0; i < pose.bones.length; i++) {
      b = pose.bones[i];
      ws = this.world[i];
      if (b.pidx != -1)
        ws.fromMul(this.world[b.pidx], b.local);
      else
        ws.fromMul(offset, b.local);
      bOffset.fromMul(ws, this.bind[i]);
      fromRotationTranslation(dq, bOffset.rot, bOffset.pos);
      ii = i * 4;
      si = i * 3;
      this.offsetQBuffer[ii + 0] = dq[0];
      this.offsetQBuffer[ii + 1] = dq[1];
      this.offsetQBuffer[ii + 2] = dq[2];
      this.offsetQBuffer[ii + 3] = dq[3];
      this.offsetPBuffer[ii + 0] = dq[4];
      this.offsetPBuffer[ii + 1] = dq[5];
      this.offsetPBuffer[ii + 2] = dq[6];
      this.offsetPBuffer[ii + 3] = dq[7];
      this.offsetSBuffer[si + 0] = bOffset.scl[0];
      this.offsetSBuffer[si + 1] = bOffset.scl[1];
      this.offsetSBuffer[si + 2] = bOffset.scl[2];
    }
    return this;
  }
  getOffsets() {
    return [this.offsetQBuffer, this.offsetPBuffer, this.offsetSBuffer];
  }
  getTextureInfo(frameCount) {
    const boneCount = this.bind.length;
    const strideByteLength = BYTE_LEN;
    const strideFloatLength = COMP_LEN;
    const pixelsPerStride = COMP_LEN / 4;
    const floatRowSize = COMP_LEN * frameCount;
    const bufferFloatSize = floatRowSize * boneCount;
    const bufferByteSize = bufferFloatSize * 4;
    const pixelWidth = pixelsPerStride * frameCount;
    const pixelHeight = boneCount;
    const o = {
      boneCount,
      strideByteLength,
      strideFloatLength,
      pixelsPerStride,
      floatRowSize,
      bufferFloatSize,
      bufferByteSize,
      pixelWidth,
      pixelHeight
    };
    return o;
  }
  clone() {
    const skin = new SkinDQT();
    skin.offsetQBuffer = new Float32Array(this.offsetQBuffer);
    skin.offsetPBuffer = new Float32Array(this.offsetPBuffer);
    skin.offsetSBuffer = new Float32Array(this.offsetSBuffer);
    skin.bind = this.bind.map((v) => v.clone());
    skin.world = this.world.map((v) => v.clone());
    return skin;
  }
}
class SpringBase {
  constructor() {
    __publicField(this, "oscPerSec", Math.PI * 2);
    __publicField(this, "damping", 1);
    __publicField(this, "epsilon", 0.01);
  }
  setTarget(v) {
    console.log("SET_TARGET NOT IMPLEMENTED");
    return this;
  }
  setOscPerSec(sec) {
    this.oscPerSec = Math.PI * 2 * sec;
    return this;
  }
  setDamp(damping) {
    this.damping = damping;
    return this;
  }
  setDampRatio(damping, dampTime) {
    this.damping = Math.log(damping) / (-this.oscPerSec * dampTime);
    return this;
  }
  setDampHalfLife(dampTime) {
    this.damping = 0.6931472 / (this.oscPerSec * dampTime);
    return this;
  }
  setDampExpo(dampTime) {
    this.oscPerSec = 0.6931472 / dampTime;
    this.damping = 1;
    return this;
  }
  reset(v) {
    return this;
  }
  update(dt) {
    console.log("UPDATE NOT IMPLEMENTED");
    return false;
  }
}
class SpringVec3 extends SpringBase {
  constructor() {
    super(...arguments);
    __publicField(this, "vel", create$3());
    __publicField(this, "val", create$3());
    __publicField(this, "tar", create$3());
    __publicField(this, "epsilon", 1e-6);
  }
  setTarget(v) {
    copy$2(this.tar, v);
    return this;
  }
  reset(v) {
    if (v) {
      copy$2(this.val, v);
      copy$2(this.tar, v);
    } else {
      set$2(this.val, 0, 0, 0);
      set$2(this.tar, 0, 0, 0);
    }
    return this;
  }
  update(dt) {
    if (Vec3Util.isZero(this.vel) && Vec3Util.lenSqr(this.tar, this.val) == 0)
      return false;
    if (sqrLen(this.vel) < this.epsilon && Vec3Util.lenSqr(this.tar, this.val) < this.epsilon) {
      set$2(this.vel, 0, 0, 0);
      copy$2(this.val, this.tar);
      return true;
    }
    let friction = 1 + 2 * dt * this.damping * this.oscPerSec, dt_osc = dt * this.oscPerSec ** 2, dt2_osc = dt * dt_osc, det_inv = 1 / (friction + dt2_osc);
    this.vel[0] = (this.vel[0] + dt_osc * (this.tar[0] - this.val[0])) * det_inv;
    this.vel[1] = (this.vel[1] + dt_osc * (this.tar[1] - this.val[1])) * det_inv;
    this.vel[2] = (this.vel[2] + dt_osc * (this.tar[2] - this.val[2])) * det_inv;
    this.val[0] = (friction * this.val[0] + dt * this.vel[0] + dt2_osc * this.tar[0]) * det_inv;
    this.val[1] = (friction * this.val[1] + dt * this.vel[1] + dt2_osc * this.tar[1]) * det_inv;
    this.val[2] = (friction * this.val[2] + dt * this.vel[2] + dt2_osc * this.tar[2]) * det_inv;
    return true;
  }
}
class SpringItem {
  constructor(name, idx) {
    __publicField(this, "index");
    __publicField(this, "name");
    __publicField(this, "spring", new SpringVec3());
    __publicField(this, "bind", new Transform());
    this.name = name;
    this.index = idx;
  }
}
class SpringRot {
  setRestPose(chain, pose, resetSpring = true, debug) {
    const tail = create$3();
    let si;
    let b;
    for (si of chain.items) {
      b = pose.bones[si.index];
      if (resetSpring) {
        set$2(tail, 0, b.len, 0);
        b.world.transformVec3(tail);
        si.spring.reset(tail);
      }
      si.bind.copy(b.local);
    }
  }
  updatePose(chain, pose, dt, debug) {
    let si;
    let b;
    let tail = create$3();
    let pTran = new Transform();
    let cTran = new Transform();
    let va = create$3();
    let vb = create$3();
    let rot = create$1();
    si = chain.items[0];
    b = pose.bones[si.index];
    pose.getWorldTransform(b.pidx, pTran);
    for (si of chain.items) {
      b = pose.bones[si.index];
      cTran.fromMul(pTran, si.bind);
      set$2(tail, 0, b.len, 0);
      cTran.transformVec3(tail);
      si.spring.setTarget(tail).update(dt);
      sub(va, tail, cTran.pos);
      normalize$2(va, va);
      sub(vb, si.spring.val, cTran.pos);
      normalize$2(vb, vb);
      rotationTo(rot, va, vb);
      QuatUtil.dotNegate(rot, rot, cTran.rot);
      mul$1(rot, rot, cTran.rot);
      QuatUtil.pmulInvert(rot, rot, pTran.rot);
      copy(b.local.rot, rot);
      pTran.mul(rot, si.bind.pos, si.bind.scl);
    }
  }
}
class SpringPos {
  setRestPose(chain, pose, resetSpring = true, debug) {
    let si;
    let b;
    for (si of chain.items) {
      b = pose.bones[si.index];
      si.spring.reset(b.world.pos);
      si.bind.copy(b.local);
    }
  }
  updatePose(chain, pose, dt, debug) {
    let si;
    let b;
    let pTran = new Transform();
    let cTran = new Transform();
    let iTran = new Transform();
    si = chain.items[0];
    b = pose.bones[si.index];
    if (b.pidx != -1)
      pTran.copy(pose.bones[b.pidx].world);
    else
      pTran.copy(pose.offset);
    for (si of chain.items) {
      b = pose.bones[si.index];
      cTran.fromMul(pTran, si.bind);
      si.spring.setTarget(cTran.pos);
      if (!si.spring.update(dt)) {
        pTran.copy(cTran);
        continue;
      }
      iTran.fromInvert(pTran).transformVec3(si.spring.val, b.local.pos);
      pTran.mul(si.bind.rot, b.local.pos, si.bind.scl);
    }
  }
}
class SpringChain {
  constructor(name, type = 0) {
    __publicField(this, "items", []);
    __publicField(this, "name");
    __publicField(this, "spring");
    this.name = name;
    this.spring = type == 1 ? new SpringPos() : new SpringRot();
  }
  setBones(aryName, arm, osc = 5, damp = 0.5) {
    let bn;
    let b;
    let spr;
    for (bn of aryName) {
      b = arm.getBone(bn);
      if (b == null) {
        console.log("Bone not found for spring: ", bn);
        continue;
      }
      spr = new SpringItem(b.name, b.idx);
      spr.spring.setDamp(damp);
      spr.spring.setOscPerSec(osc);
      this.items.push(spr);
    }
  }
  setRestPose(pose, resetSpring = false, debug) {
    this.spring.setRestPose(this, pose, resetSpring, debug);
  }
  updatePose(dt, pose, debug) {
    this.spring.updatePose(this, pose, dt, debug);
  }
}
__publicField(SpringChain, "ROT", 0);
__publicField(SpringChain, "POS", 1);
class BoneSpring {
  constructor(arm) {
    __publicField(this, "arm");
    __publicField(this, "items", /* @__PURE__ */ new Map());
    this.arm = arm;
  }
  addRotChain(chName, bNames, osc = 5, damp = 0.5) {
    const chain = new SpringChain(chName, 0);
    chain.setBones(bNames, this.arm, osc, damp);
    this.items.set(chName, chain);
    return this;
  }
  addPosChain(chName, bNames, osc = 5, damp = 0.5) {
    const chain = new SpringChain(chName, 1);
    chain.setBones(bNames, this.arm, osc, damp);
    this.items.set(chName, chain);
    return this;
  }
  setRestPose(pose, resetSpring = true, debug) {
    let ch;
    for (ch of this.items.values()) {
      ch.setRestPose(pose, resetSpring, debug);
    }
    return this;
  }
  updatePose(dt, pose, doWorldUpdate, debug) {
    let ch;
    for (ch of this.items.values()) {
      ch.updatePose(dt, pose, debug);
    }
    if (doWorldUpdate)
      pose.updateWorld(true);
    return this;
  }
  setOsc(chName, osc) {
    const ch = this.items.get(chName);
    if (!ch) {
      console.error("Spring Chain name not found", chName);
      return this;
    }
    let si;
    for (si of ch.items)
      si.spring.setOscPerSec(osc);
    return this;
  }
  setOscRange(chName, a, b) {
    const ch = this.items.get(chName);
    if (!ch) {
      console.error("Spring Chain name not found", chName);
      return this;
    }
    const len2 = ch.items.length - 1;
    let t;
    for (let i = 0; i <= len2; i++) {
      t = i / len2;
      ch.items[i].spring.setOscPerSec(a * (1 - t) + b * t);
    }
    return this;
  }
  setDamp(chName, damp) {
    const ch = this.items.get(chName);
    if (!ch) {
      console.error("Spring Chain name not found", chName);
      return this;
    }
    let si;
    for (si of ch.items)
      si.spring.setDamp(damp);
    return this;
  }
  setDampRange(chName, a, b) {
    const ch = this.items.get(chName);
    if (!ch) {
      console.error("Spring Chain name not found", chName);
      return this;
    }
    const len2 = ch.items.length - 1;
    let t;
    for (let i = 0; i <= len2; i++) {
      t = i / len2;
      ch.items[i].spring.setDamp(a * (1 - t) + b * t);
    }
    return this;
  }
}
const GLB_MAGIC = 1179937895;
const GLB_JSON = 1313821514;
const GLB_BIN = 5130562;
const GLB_VER = 2;
const GLB_MAGIC_BIDX = 0;
const GLB_VERSION_BIDX = 4;
const GLB_JSON_TYPE_BIDX = 16;
const GLB_JSON_LEN_BIDX = 12;
const GLB_JSON_BIDX = 20;
async function parseGLB(res) {
  const arybuf = await res.arrayBuffer();
  const dv = new DataView(arybuf);
  if (dv.getUint32(GLB_MAGIC_BIDX, true) != GLB_MAGIC) {
    console.error("GLB magic number does not match.");
    return null;
  }
  if (dv.getUint32(GLB_VERSION_BIDX, true) != GLB_VER) {
    console.error("Can only accept GLB of version 2.");
    return null;
  }
  if (dv.getUint32(GLB_JSON_TYPE_BIDX, true) != GLB_JSON) {
    console.error("GLB Chunk 0 is not the type: JSON ");
    return null;
  }
  const json_len = dv.getUint32(GLB_JSON_LEN_BIDX, true);
  const chk1_bidx = GLB_JSON_BIDX + json_len;
  if (dv.getUint32(chk1_bidx + 4, true) != GLB_BIN) {
    console.error("GLB Chunk 1 is not the type: BIN ");
    return null;
  }
  const bin_len = dv.getUint32(chk1_bidx, true);
  const bin_idx = chk1_bidx + 8;
  const txt_decoder = new TextDecoder("utf8");
  const json_bytes = new Uint8Array(arybuf, GLB_JSON_BIDX, json_len);
  const json_text = txt_decoder.decode(json_bytes);
  const json = JSON.parse(json_text);
  const bin = arybuf.slice(bin_idx);
  if (bin.byteLength != bin_len) {
    console.error("GLB Bin length does not match value in header.");
    return null;
  }
  return [json, bin];
}
const ComponentTypeMap = {
  5120: [1, Int8Array, "int8", "BYTE"],
  5121: [1, Uint8Array, "uint8", "UNSIGNED_BYTE"],
  5122: [2, Int16Array, "int16", "SHORT"],
  5123: [2, Uint16Array, "uint16", "UNSIGNED_SHORT"],
  5125: [4, Uint32Array, "uint32", "UNSIGNED_INT"],
  5126: [4, Float32Array, "float", "FLOAT"]
};
const ComponentVarMap = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
class Accessor {
  constructor(accessor, bufView, bin) {
    __publicField(this, "componentLen", 0);
    __publicField(this, "elementCnt", 0);
    __publicField(this, "byteOffset", 0);
    __publicField(this, "byteSize", 0);
    __publicField(this, "boundMin", null);
    __publicField(this, "boundMax", null);
    __publicField(this, "type", null);
    __publicField(this, "data", null);
    const [
      compByte,
      compType,
      typeName
    ] = ComponentTypeMap[accessor.componentType];
    if (!compType) {
      console.error("Unknown Component Type for Accessor", accessor.componentType);
      return;
    }
    this.componentLen = ComponentVarMap[accessor.type];
    this.elementCnt = accessor.count;
    this.byteOffset = (accessor.byteOffset || 0) + (bufView.byteOffset || 0);
    this.byteSize = this.elementCnt * this.componentLen * compByte;
    this.boundMin = accessor.min ? accessor.min.slice(0) : null;
    this.boundMax = accessor.max ? accessor.max.slice(0) : null;
    this.type = typeName;
    if (bin) {
      const size = this.elementCnt * this.componentLen;
      this.data = new compType(bin, this.byteOffset, size);
    }
  }
}
class Mesh {
  constructor() {
    __publicField(this, "index", null);
    __publicField(this, "name", null);
    __publicField(this, "primitives", []);
    __publicField(this, "position", null);
    __publicField(this, "rotation", null);
    __publicField(this, "scale", null);
  }
}
class Primitive {
  constructor() {
    __publicField(this, "materialName", null);
    __publicField(this, "materialIdx", null);
    __publicField(this, "indices", null);
    __publicField(this, "position", null);
    __publicField(this, "normal", null);
    __publicField(this, "tangent", null);
    __publicField(this, "texcoord_0", null);
    __publicField(this, "texcoord_1", null);
    __publicField(this, "color_0", null);
    __publicField(this, "joints_0", null);
    __publicField(this, "weights_0", null);
  }
}
class Skin {
  constructor() {
    __publicField(this, "index", null);
    __publicField(this, "name", null);
    __publicField(this, "joints", []);
    __publicField(this, "position", null);
    __publicField(this, "rotation", null);
    __publicField(this, "scale", null);
  }
}
class SkinJoint {
  constructor() {
    __publicField(this, "name", null);
    __publicField(this, "index", null);
    __publicField(this, "parentIndex", null);
    __publicField(this, "bindMatrix", null);
    __publicField(this, "position", null);
    __publicField(this, "rotation", null);
    __publicField(this, "scale", null);
  }
}
const ETransform = {
  Rot: 0,
  Pos: 1,
  Scl: 2
};
const ELerp = {
  Step: 0,
  Linear: 1,
  Cubic: 2
};
const _Track = class {
  constructor() {
    __publicField(this, "transform", ETransform.Pos);
    __publicField(this, "interpolation", ELerp.Step);
    __publicField(this, "jointIndex", 0);
    __publicField(this, "timeStampIndex", 0);
    __publicField(this, "keyframes");
  }
  static fromGltf(jointIdx, target, inter) {
    const t = new _Track();
    t.jointIndex = jointIdx;
    switch (target) {
      case "translation":
        t.transform = ETransform.Pos;
        break;
      case "rotation":
        t.transform = ETransform.Rot;
        break;
      case "scale":
        t.transform = ETransform.Scl;
        break;
    }
    switch (inter) {
      case "LINEAR":
        t.interpolation = ELerp.Linear;
        break;
      case "STEP":
        t.interpolation = ELerp.Step;
        break;
      case "CUBICSPLINE":
        t.interpolation = ELerp.Cubic;
        break;
    }
    return t;
  }
};
let Track = _Track;
__publicField(Track, "Transform", ETransform);
__publicField(Track, "Lerp", ELerp);
class Animation {
  constructor(name) {
    __publicField(this, "name", "");
    __publicField(this, "timestamps", []);
    __publicField(this, "tracks", []);
    if (name)
      this.name = name;
  }
}
class Texture {
  constructor() {
    __publicField(this, "index", null);
    __publicField(this, "name", null);
    __publicField(this, "mime", null);
    __publicField(this, "blob", null);
  }
}
class PoseJoint {
  constructor(idx, rot, pos, scl) {
    __publicField(this, "index");
    __publicField(this, "rot");
    __publicField(this, "pos");
    __publicField(this, "scl");
    this.index = idx;
    this.rot = rot;
    this.pos = pos;
    this.scl = scl;
  }
}
class Pose {
  constructor(name) {
    __publicField(this, "name", "");
    __publicField(this, "joints", []);
    if (name)
      this.name = name;
  }
  add(idx, rot, pos, scl) {
    this.joints.push(new PoseJoint(idx, rot, pos, scl));
  }
}
class Gltf2 {
  constructor(json, bin) {
    __publicField(this, "json");
    __publicField(this, "bin");
    this.json = json;
    this.bin = bin || new ArrayBuffer(0);
  }
  getNodeByName(n) {
    let o, i;
    for (i = 0; i < this.json.nodes.length; i++) {
      o = this.json.nodes[i];
      if (o.name == n)
        return [o, i];
    }
    return null;
  }
  getMeshNames() {
    const json = this.json, rtn = [];
    let i;
    for (i of json.meshes)
      rtn.push(i.name);
    return rtn;
  }
  getMeshByName(n) {
    let o, i;
    for (i = 0; i < this.json.meshes.length; i++) {
      o = this.json.meshes[i];
      if (o.name == n)
        return [o, i];
    }
    return null;
  }
  getMeshNodes(idx) {
    const out = [];
    let n;
    for (n of this.json.nodes) {
      if (n.mesh == idx)
        out.push(n);
    }
    return out;
  }
  getMesh(id) {
    if (!this.json.meshes) {
      console.warn("No Meshes in GLTF File");
      return null;
    }
    const json = this.json;
    let m = null;
    let mIdx = null;
    switch (typeof id) {
      case "string": {
        const tup = this.getMeshByName(id);
        if (tup !== null) {
          m = tup[0];
          mIdx = tup[1];
        }
        break;
      }
      case "number":
        if (id < json.meshes.length) {
          m = json.meshes[id];
          mIdx = id;
        }
        break;
      default:
        m = json.meshes[0];
        mIdx = 0;
        break;
    }
    if (m == null || mIdx == null) {
      console.warn("No Mesh Found", id);
      return null;
    }
    const mesh = new Mesh();
    mesh.name = m.name;
    mesh.index = mIdx;
    let p, prim, attr;
    for (p of m.primitives) {
      attr = p.attributes;
      prim = new Primitive();
      if (p.material != void 0 && p.material != null) {
        prim.materialIdx = p.material;
        prim.materialName = json.materials[p.material].name;
      }
      if (p.indices != void 0)
        prim.indices = this.parseAccessor(p.indices);
      if (attr.POSITION != void 0)
        prim.position = this.parseAccessor(attr.POSITION);
      if (attr.NORMAL != void 0)
        prim.normal = this.parseAccessor(attr.NORMAL);
      if (attr.TANGENT != void 0)
        prim.tangent = this.parseAccessor(attr.TANGENT);
      if (attr.TEXCOORD_0 != void 0)
        prim.texcoord_0 = this.parseAccessor(attr.TEXCOORD_0);
      if (attr.TEXCOORD_1 != void 0)
        prim.texcoord_1 = this.parseAccessor(attr.TEXCOORD_1);
      if (attr.JOINTS_0 != void 0)
        prim.joints_0 = this.parseAccessor(attr.JOINTS_0);
      if (attr.WEIGHTS_0 != void 0)
        prim.weights_0 = this.parseAccessor(attr.WEIGHTS_0);
      if (attr.COLOR_0 != void 0)
        prim.color_0 = this.parseAccessor(attr.COLOR_0);
      mesh.primitives.push(prim);
    }
    const nodes = this.getMeshNodes(mIdx);
    if (nodes == null ? void 0 : nodes.length) {
      if (nodes[0].translation)
        mesh.position = nodes[0].translation.slice(0);
      if (nodes[0].rotation)
        mesh.rotation = nodes[0].rotation.slice(0);
      if (nodes[0].scale)
        mesh.scale = nodes[0].scale.slice(0);
    }
    return mesh;
  }
  getSkinNames() {
    const json = this.json, rtn = [];
    let i;
    for (i of json.skins)
      rtn.push(i.name);
    return rtn;
  }
  getSkinByName(n) {
    let o, i;
    for (i = 0; i < this.json.skins.length; i++) {
      o = this.json.skins[i];
      if (o.name == n)
        return [o, i];
    }
    return null;
  }
  getSkin(id) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    if (!this.json.skins) {
      console.warn("No Skins in GLTF File");
      return null;
    }
    const json = this.json;
    let js = null;
    let idx = null;
    switch (typeof id) {
      case "string": {
        const tup = this.getSkinByName(id);
        if (tup !== null) {
          js = tup[0];
          idx = tup[1];
        }
        break;
      }
      case "number":
        if (id < json.skins.length) {
          js = json.meshes[id];
          idx = id;
        }
        break;
      default:
        js = json.skins[0];
        idx = 0;
        break;
    }
    if (js == null) {
      console.warn("No Skin Found", id);
      return null;
    }
    const bind = this.parseAccessor(js.inverseBindMatrices);
    if (bind && bind.elementCnt != js.joints.length) {
      console.warn("Strange Error. Joint Count & Bind Matrix Count dont match");
      return null;
    }
    let i, bi, ni, joint, node;
    const jMap = /* @__PURE__ */ new Map();
    const skin = new Skin();
    skin.name = js.name;
    skin.index = idx;
    for (i = 0; i < js.joints.length; i++) {
      ni = js.joints[i];
      node = json.nodes[ni];
      jMap.set(ni, i);
      joint = new SkinJoint();
      joint.index = i;
      joint.name = node.name ? node.name : "bone_" + i;
      joint.rotation = (_b = (_a = node == null ? void 0 : node.rotation) == null ? void 0 : _a.slice(0)) != null ? _b : null;
      joint.position = (_d = (_c = node == null ? void 0 : node.translation) == null ? void 0 : _c.slice(0)) != null ? _d : null;
      joint.scale = (_f = (_e = node == null ? void 0 : node.scale) == null ? void 0 : _e.slice(0)) != null ? _f : null;
      if (bind && bind.data) {
        bi = i * 16;
        joint.bindMatrix = Array.from(bind.data.slice(bi, bi + 16));
      }
      if (joint.scale) {
        if (Math.abs(1 - joint.scale[0]) <= 1e-6)
          joint.scale[0] = 1;
        if (Math.abs(1 - joint.scale[1]) <= 1e-6)
          joint.scale[1] = 1;
        if (Math.abs(1 - joint.scale[2]) <= 1e-6)
          joint.scale[2] = 1;
      }
      skin.joints.push(joint);
    }
    let j;
    for (i = 0; i < js.joints.length; i++) {
      ni = js.joints[i];
      node = json.nodes[ni];
      if ((_g = node == null ? void 0 : node.children) == null ? void 0 : _g.length) {
        for (j = 0; j < node.children.length; j++) {
          bi = jMap.get(node.children[j]);
          if (bi != void 0)
            skin.joints[bi].parentIndex = i;
          else
            console.log("BI", bi, node);
        }
      }
    }
    if (skin.name) {
      const snode = this.getNodeByName(skin.name);
      if (snode) {
        const n = snode[0];
        skin.rotation = (_i = (_h = n == null ? void 0 : n.rotation) == null ? void 0 : _h.slice(0)) != null ? _i : null;
        skin.position = (_k = (_j = n == null ? void 0 : n.translation) == null ? void 0 : _j.slice(0)) != null ? _k : null;
        skin.scale = (_m = (_l = n == null ? void 0 : n.scale) == null ? void 0 : _l.slice(0)) != null ? _m : null;
      }
    }
    return skin;
  }
  getMaterial(id) {
    if (!this.json.materials) {
      console.warn("No Materials in GLTF File");
      return null;
    }
    const json = this.json;
    let mat = null;
    switch (typeof id) {
      case "number":
        if (id < json.materials.length) {
          mat = json.materials[id].pbrMetallicRoughness;
        }
        break;
      default:
        mat = json.materials[0].pbrMetallicRoughness;
        break;
    }
    return mat;
  }
  getTexture(id) {
    const js = this.json;
    const t = js.textures[id];
    const img = js.images[t.source];
    const bv = js.bufferViews[img.bufferView];
    const bAry = new Uint8Array(this.bin, bv.byteOffset, bv.byteLength);
    const tex = new Texture();
    tex.index = id;
    tex.name = img.name;
    tex.mime = img.mimeType;
    tex.blob = new Blob([bAry], { type: img.mimeType });
    return tex;
  }
  getAnimationNames() {
    const json = this.json, rtn = [];
    let i;
    for (i of json.animations)
      rtn.push(i.name);
    return rtn;
  }
  getAnimationByName(n) {
    let o, i;
    for (i = 0; i < this.json.animations.length; i++) {
      o = this.json.animations[i];
      if (o.name == n)
        return [o, i];
    }
    return null;
  }
  getAnimation(id) {
    if (!this.json.animations) {
      console.warn("No Animations in GLTF File");
      return null;
    }
    const json = this.json;
    let js = null;
    switch (typeof id) {
      case "string": {
        const tup = this.getAnimationByName(id);
        if (tup !== null) {
          js = tup[0];
        }
        break;
      }
      case "number":
        if (id < json.animations.length) {
          js = json.animations[id];
        }
        break;
      default:
        js = json.animations[0];
        break;
    }
    if (js == null) {
      console.warn("No Animation Found", id);
      return null;
    }
    const NJMap = /* @__PURE__ */ new Map();
    const timeStamps = [];
    const tsMap = /* @__PURE__ */ new Map();
    const fnGetJoint = (nIdx) => {
      let jIdx = NJMap.get(nIdx);
      if (jIdx != void 0)
        return jIdx;
      for (let skin of this.json.skins) {
        jIdx = skin.joints.indexOf(nIdx);
        if (jIdx != -1 && jIdx != void 0) {
          NJMap.set(nIdx, jIdx);
          return jIdx;
        }
      }
      return -1;
    };
    const fnGetTimestamp = (sIdx) => {
      let aIdx = tsMap.get(sIdx);
      if (aIdx != void 0)
        return aIdx;
      const acc2 = this.parseAccessor(sIdx);
      if (acc2) {
        aIdx = timeStamps.length;
        timeStamps.push(acc2);
        tsMap.set(sIdx, aIdx);
        return aIdx;
      }
      return -1;
    };
    const anim = new Animation(js.name);
    anim.timestamps = timeStamps;
    let track;
    let ch;
    let jointIdx;
    let sampler;
    let acc;
    for (ch of js.channels) {
      jointIdx = fnGetJoint(ch.target.node);
      sampler = js.samplers[ch.sampler];
      track = Track.fromGltf(jointIdx, ch.target.path, sampler.interpolation);
      acc = this.parseAccessor(sampler.output);
      if (acc)
        track.keyframes = acc;
      track.timeStampIndex = fnGetTimestamp(sampler.input);
      anim.tracks.push(track);
    }
    return anim;
  }
  getPoseByName(n) {
    let o, i;
    for (i = 0; i < this.json.poses.length; i++) {
      o = this.json.poses[i];
      if (o.name == n)
        return [o, i];
    }
    return null;
  }
  getPose(id) {
    if (!this.json.poses) {
      console.warn("No Poses in GLTF File");
      return null;
    }
    const json = this.json;
    let js = null;
    switch (typeof id) {
      case "string": {
        const tup = this.getPoseByName(id);
        if (tup !== null) {
          js = tup[0];
        }
        break;
      }
      default:
        js = json.poses[0];
        break;
    }
    if (js == null) {
      console.warn("No Pose Found", id);
      return null;
    }
    const pose = new Pose(js.name);
    let jnt;
    for (jnt of js.joints) {
      pose.add(jnt.idx, jnt.rot, jnt.pos, jnt.scl);
    }
    return pose;
  }
  parseAccessor(accID) {
    const accessor = this.json.accessors[accID];
    const bufView = this.json.bufferViews[accessor.bufferView];
    if (bufView.byteStride) {
      console.error("UNSUPPORTED - Parsing Stride Buffer");
      return null;
    }
    return new Accessor(accessor, bufView, this.bin);
  }
  static async fetch(url) {
    const res = await fetch(url);
    if (!res.ok)
      return null;
    switch (url.slice(-4).toLocaleLowerCase()) {
      case "gltf":
        let bin;
        const json = await res.json();
        if (json.buffers && json.buffers.length > 0) {
          const path = url.substring(0, url.lastIndexOf("/") + 1);
          bin = await fetch(path + json.buffers[0].uri).then((r) => r.arrayBuffer());
        }
        return new Gltf2(json, bin);
      case ".glb":
        const tuple = await parseGLB(res);
        return tuple ? new Gltf2(tuple[0], tuple[1]) : null;
    }
    return null;
  }
}
class IKLink {
  constructor(idx, len2) {
    __publicField(this, "idx");
    __publicField(this, "pidx");
    __publicField(this, "len");
    __publicField(this, "bind", new Transform());
    __publicField(this, "effectorDir", [0, 1, 0]);
    __publicField(this, "poleDir", [0, 0, 1]);
    this.idx = idx;
    this.pidx = -1;
    this.len = len2;
  }
  static fromBone(b) {
    const l = new IKLink(b.idx, b.len);
    l.bind.copy(b.local);
    l.pidx = b.pidx;
    return l;
  }
}
class IKChain {
  constructor(bName, arm) {
    __publicField(this, "links", []);
    __publicField(this, "solver", null);
    __publicField(this, "count", 0);
    __publicField(this, "length", 0);
    if (bName && arm)
      this.setBones(bName, arm);
  }
  addBone(b) {
    this.length += b.len;
    this.links.push(IKLink.fromBone(b));
    this.count++;
    return this;
  }
  setBones(bNames, arm) {
    let b;
    let n;
    this.length = 0;
    for (n of bNames) {
      b = arm.getBone(n);
      if (b) {
        this.length += b.len;
        this.links.push(IKLink.fromBone(b));
      } else
        console.log("Chain.setBones - Bone Not Found:", n);
    }
    this.count = this.links.length;
    return this;
  }
  setSolver(s) {
    this.solver = s;
    return this;
  }
  bindToPose(pose) {
    let lnk;
    for (lnk of this.links) {
      lnk.bind.copy(pose.bones[lnk.idx].local);
    }
    return this;
  }
  resetLengths(pose) {
    let lnk;
    let len2;
    this.length = 0;
    for (lnk of this.links) {
      len2 = pose.bones[lnk.idx].len;
      lnk.len = len2;
      this.length += len2;
    }
  }
  first() {
    return this.links[0];
  }
  last() {
    return this.links[this.count - 1];
  }
  getEndPositions(pose) {
    let rtn = [];
    if (this.count != 0)
      rtn.push(Vec3Util.toArray(pose.bones[this.links[0].idx].world.pos));
    if (this.count > 1) {
      const lnk = this.last();
      const v = fromValues(0, lnk.len, 0);
      pose.bones[lnk.idx].world.transformVec3(v);
      rtn.push(Vec3Util.toArray(v));
    }
    return rtn;
  }
  getPositionAt(pose, idx) {
    const b = pose.bones[this.links[idx].idx];
    return Vec3Util.toArray(b.world.pos);
  }
  getAllPositions(pose) {
    const rtn = [];
    let lnk;
    for (lnk of this.links) {
      rtn.push(Vec3Util.toArray(pose.bones[lnk.idx].world.pos));
    }
    lnk = this.links[this.count - 1];
    const v = fromValues(0, lnk.len, 0);
    pose.bones[lnk.idx].world.transformVec3(v);
    rtn.push(Vec3Util.toArray(v));
    return rtn;
  }
  getStartPosition(pose) {
    const b = pose.bones[this.links[0].idx];
    return Vec3Util.toArray(b.world.pos);
  }
  getMiddlePosition(pose) {
    if (this.count == 2) {
      const b = pose.bones[this.links[1].idx];
      return Vec3Util.toArray(b.world.pos);
    }
    console.warn("TODO: Implemenet IKChain.getMiddlePosition");
    return [0, 0, 0];
  }
  getLastPosition(pose) {
    const b = pose.bones[this.links[this.count - 1].idx];
    return Vec3Util.toArray(b.world.pos);
  }
  getTailPosition(pose, ignoreScale = false) {
    const b = pose.bones[this.links[this.count - 1].idx];
    const v = fromValues(0, b.len, 0);
    if (!ignoreScale)
      return Vec3Util.toArray(b.world.transformVec3(v));
    transformQuat(v, v, b.world.rot);
    add(v, v, b.world.pos);
    return Vec3Util.toArray(v);
  }
  getAltDirections(pose, idx = 0) {
    const lnk = this.links[idx];
    const b = pose.bones[lnk.idx];
    const eff = lnk.effectorDir.slice(0);
    const pol = lnk.poleDir.slice(0);
    transformQuat(eff, eff, b.world.rot);
    transformQuat(pol, pol, b.world.rot);
    return [eff, pol];
  }
  bindAltDirections(pose, effectorDir, poleDir) {
    let l;
    let v = create$3();
    let inv = create$1();
    for (l of this.links) {
      invert$1(inv, pose.bones[l.idx].world.rot);
      transformQuat(v, effectorDir, inv);
      copy$2(l.effectorDir, v);
      transformQuat(v, poleDir, inv);
      copy$2(l.poleDir, v);
    }
    return this;
  }
  setAltDirections(effectorDir, poleDir) {
    let l;
    for (l of this.links) {
      copy$2(l.effectorDir, effectorDir);
      copy$2(l.poleDir, poleDir);
    }
    return this;
  }
  resolveToPose(pose, debug) {
    if (!this.solver) {
      console.warn("Chain.resolveToPose - Missing Solver");
      return this;
    }
    this.solver.resolve(this, pose, debug);
    return this;
  }
}
class IKRig {
  constructor() {
    __publicField(this, "items", /* @__PURE__ */ new Map());
  }
  bindPose(pose) {
    let ch;
    for (ch of this.items.values())
      ch.bindToPose(pose);
    return this;
  }
  updateBoneLengths(pose) {
    let ch;
    for (ch of this.items.values()) {
      ch.resetLengths(pose);
    }
    return this;
  }
  get(name) {
    return this.items.get(name);
  }
  add(arm, name, bNames) {
    const chain = new IKChain(bNames, arm);
    this.items.set(name, chain);
    return chain;
  }
}
class SwingTwistSolver {
  constructor() {
    __publicField(this, "_isTarPosition", false);
    __publicField(this, "_originPoleDir", [0, 0, 0]);
    __publicField(this, "effectorScale", 1);
    __publicField(this, "effectorPos", [0, 0, 0]);
    __publicField(this, "effectorDir", [0, 0, 1]);
    __publicField(this, "poleDir", [0, 1, 0]);
    __publicField(this, "orthoDir", [1, 0, 0]);
    __publicField(this, "originPos", [0, 0, 0]);
  }
  initData(pose, chain) {
    if (pose && chain) {
      const lnk = chain.links[0];
      const rot = pose.bones[lnk.idx].world.rot;
      const eff = transformQuat([0, 0, 0], lnk.effectorDir, rot);
      const pole = transformQuat([0, 0, 0], lnk.poleDir, rot);
      this.setTargetDir(eff, pole);
    }
    return this;
  }
  setTargetDir(e, pole, effectorScale) {
    this._isTarPosition = false;
    this.effectorDir[0] = e[0];
    this.effectorDir[1] = e[1];
    this.effectorDir[2] = e[2];
    if (pole)
      this.setTargetPole(pole);
    if (effectorScale)
      this.effectorScale = effectorScale;
    return this;
  }
  setTargetPos(v, pole) {
    this._isTarPosition = true;
    this.effectorPos[0] = v[0];
    this.effectorPos[1] = v[1];
    this.effectorPos[2] = v[2];
    if (pole)
      this.setTargetPole(pole);
    return this;
  }
  setTargetPole(v) {
    this._originPoleDir[0] = v[0];
    this._originPoleDir[1] = v[1];
    this._originPoleDir[2] = v[2];
    return this;
  }
  resolve(chain, pose, debug) {
    const [rot, pt] = this.getWorldRot(chain, pose, debug);
    QuatUtil.pmulInvert(rot, rot, pt.rot);
    pose.setLocalRot(chain.links[0].idx, rot);
  }
  ikDataFromPose(chain, pose, out) {
    const dir = [0, 0, 0];
    const lnk = chain.first();
    const b = pose.bones[lnk.idx];
    transformQuat(dir, lnk.effectorDir, b.world.rot);
    normalize$2(out.effectorDir, dir);
    transformQuat(dir, lnk.poleDir, b.world.rot);
    normalize$2(out.poleDir, dir);
  }
  _update(origin) {
    const v = [0, 0, 0];
    if (this._isTarPosition) {
      sub(v, this.effectorPos, origin);
      normalize$2(this.effectorDir, v);
    }
    cross(v, this._originPoleDir, this.effectorDir);
    normalize$2(this.orthoDir, v);
    cross(v, this.effectorDir, this.orthoDir);
    normalize$2(this.poleDir, v);
    copy$2(this.originPos, origin);
  }
  getWorldRot(chain, pose, debug) {
    const pt = new Transform();
    const ct = new Transform();
    let lnk = chain.first();
    if (lnk.pidx == -1)
      pt.copy(pose.offset);
    else
      pose.getWorldTransform(lnk.pidx, pt);
    ct.fromMul(pt, lnk.bind);
    this._update(ct.pos);
    const rot = copy([0, 0, 0, 1], ct.rot);
    const dir = [0, 0, 0];
    const q = [0, 0, 0, 1];
    transformQuat(dir, lnk.effectorDir, ct.rot);
    rotationTo(q, dir, this.effectorDir);
    mul$1(rot, q, rot);
    if (sqrLen(this.poleDir) > 1e-4) {
      transformQuat(dir, lnk.poleDir, rot);
      rotationTo(q, dir, this.poleDir);
      mul$1(rot, q, rot);
    }
    if (!this._isTarPosition) {
      this.effectorPos[0] = this.originPos[0] + this.effectorDir[0] * chain.length * this.effectorScale;
      this.effectorPos[1] = this.originPos[1] + this.effectorDir[1] * chain.length * this.effectorScale;
      this.effectorPos[2] = this.originPos[2] + this.effectorDir[2] * chain.length * this.effectorScale;
    }
    return [rot, pt];
  }
}
class HipSolver {
  constructor() {
    __publicField(this, "isAbs", true);
    __publicField(this, "position", [0, 0, 0]);
    __publicField(this, "bindHeight", 0);
    __publicField(this, "_swingTwist", new SwingTwistSolver());
  }
  initData(pose, chain) {
    if (pose && chain) {
      const b = pose.bones[chain.links[0].idx];
      this.setMovePos(b.world.pos, true);
      this._swingTwist.initData(pose, chain);
    }
    return this;
  }
  setTargetDir(e, pole) {
    this._swingTwist.setTargetDir(e, pole);
    return this;
  }
  setTargetPos(v, pole) {
    this._swingTwist.setTargetPos(v, pole);
    return this;
  }
  setTargetPole(v) {
    this._swingTwist.setTargetPole(v);
    return this;
  }
  setMovePos(pos, isAbs = true, bindHeight = 0) {
    this.position[0] = pos[0];
    this.position[1] = pos[1];
    this.position[2] = pos[2];
    this.isAbs = isAbs;
    this.bindHeight = bindHeight;
    return this;
  }
  resolve(chain, pose, debug) {
    const hipPos = [0, 0, 0];
    const pt = new Transform();
    const ptInv = new Transform();
    const lnk = chain.first();
    if (lnk.pidx == -1)
      pt.copy(pose.offset);
    else
      pose.getWorldTransform(lnk.pidx, pt);
    ptInv.fromInvert(pt);
    if (this.isAbs) {
      copy$2(hipPos, this.position);
    } else {
      const ct = new Transform();
      ct.fromMul(pt, lnk.bind);
      if (this.bindHeight == 0) {
        add(hipPos, ct.pos, this.position);
      } else {
        scaleAndAdd(hipPos, ct.pos, this.position, Math.abs(ct.pos[1] / this.bindHeight));
      }
    }
    ptInv.transformVec3(hipPos);
    pose.setLocalPos(lnk.idx, hipPos);
    this._swingTwist.resolve(chain, pose, debug);
  }
  ikDataFromPose(chain, pose, out) {
    const v = [0, 0, 0];
    const lnk = chain.first();
    const b = pose.bones[lnk.idx];
    const tran = new Transform();
    if (b.pidx == -1)
      tran.fromMul(pose.offset, lnk.bind);
    else
      pose.getWorldTransform(lnk.pidx, tran).mul(lnk.bind);
    sub(v, b.world.pos, tran.pos);
    out.isAbsolute = false;
    out.bindHeight = tran.pos[1];
    copy$2(out.pos, v);
    transformQuat(v, lnk.effectorDir, b.world.rot);
    normalize$2(out.effectorDir, v);
    transformQuat(v, lnk.poleDir, b.world.rot);
    normalize$2(out.poleDir, v);
  }
}
class SwingTwistBase {
  constructor() {
    __publicField(this, "_swingTwist", new SwingTwistSolver());
  }
  initData(pose, chain) {
    if (pose && chain)
      this._swingTwist.initData(pose, chain);
    return this;
  }
  setTargetDir(e, pole, effectorScale) {
    this._swingTwist.setTargetDir(e, pole, effectorScale);
    return this;
  }
  setTargetPos(v, pole) {
    this._swingTwist.setTargetPos(v, pole);
    return this;
  }
  setTargetPole(v) {
    this._swingTwist.setTargetPole(v);
    return this;
  }
  resolve(chain, pose, debug) {
  }
  ikDataFromPose(chain, pose, out) {
    const p0 = chain.getStartPosition(pose);
    const p1 = chain.getTailPosition(pose, true);
    const dir = sub([0, 0, 0], p1, p0);
    out.lenScale = len(dir) / chain.length;
    normalize$2(out.effectorDir, dir);
    const lnk = chain.first();
    const bp = pose.bones[lnk.idx];
    transformQuat(dir, lnk.poleDir, bp.world.rot);
    cross(dir, dir, out.effectorDir);
    cross(dir, out.effectorDir, dir);
    normalize$2(out.poleDir, dir);
  }
}
function lawcos_sss(aLen, bLen, cLen) {
  let v = (aLen * aLen + bLen * bLen - cLen * cLen) / (2 * aLen * bLen);
  if (v < -1)
    v = -1;
  else if (v > 1)
    v = 1;
  return Math.acos(v);
}
class LimbSolver extends SwingTwistBase {
  constructor() {
    super(...arguments);
    __publicField(this, "bendDir", 1);
  }
  invertBend() {
    this.bendDir = -this.bendDir;
    return this;
  }
  resolve(chain, pose, debug) {
    const ST = this._swingTwist;
    const [rot, pt] = ST.getWorldRot(chain, pose, debug);
    let b0 = chain.links[0], b1 = chain.links[1], alen = b0.len, blen = b1.len, clen = Vec3Util.len(ST.effectorPos, ST.originPos), prot = [0, 0, 0, 0], rad;
    rad = lawcos_sss(alen, clen, blen);
    QuatUtil.pmulAxisAngle(rot, ST.orthoDir, -rad * this.bendDir, rot);
    copy(prot, rot);
    QuatUtil.pmulInvert(rot, rot, pt.rot);
    pose.setLocalRot(b0.idx, rot);
    rad = Math.PI - lawcos_sss(alen, blen, clen);
    mul$1(rot, prot, b1.bind.rot);
    QuatUtil.pmulAxisAngle(rot, ST.orthoDir, rad * this.bendDir, rot);
    QuatUtil.pmulInvert(rot, rot, prot);
    pose.setLocalRot(b1.idx, rot);
  }
}
class SwingTwistEndsSolver {
  constructor() {
    __publicField(this, "startEffectorDir", [0, 0, 0]);
    __publicField(this, "startPoleDir", [0, 0, 0]);
    __publicField(this, "endEffectorDir", [0, 0, 0]);
    __publicField(this, "endPoleDir", [0, 0, 0]);
  }
  initData(pose, chain) {
    if (pose && chain) {
      const pole = [0, 0, 0];
      const eff = [0, 0, 0];
      let rot;
      let lnk;
      lnk = chain.first();
      rot = pose.bones[lnk.idx].world.rot;
      transformQuat(eff, lnk.effectorDir, rot);
      transformQuat(pole, lnk.poleDir, rot);
      this.setStartDir(eff, pole);
      lnk = chain.last();
      rot = pose.bones[lnk.idx].world.rot;
      transformQuat(eff, lnk.effectorDir, rot);
      transformQuat(pole, lnk.poleDir, rot);
      this.setEndDir(eff, pole);
    }
    return this;
  }
  setStartDir(eff, pole) {
    this.startEffectorDir[0] = eff[0];
    this.startEffectorDir[1] = eff[1];
    this.startEffectorDir[2] = eff[2];
    this.startPoleDir[0] = pole[0];
    this.startPoleDir[1] = pole[1];
    this.startPoleDir[2] = pole[2];
    return this;
  }
  setEndDir(eff, pole) {
    this.endEffectorDir[0] = eff[0];
    this.endEffectorDir[1] = eff[1];
    this.endEffectorDir[2] = eff[2];
    this.endPoleDir[0] = pole[0];
    this.endPoleDir[1] = pole[1];
    this.endPoleDir[2] = pole[2];
    return this;
  }
  resolve(chain, pose, debug) {
    const iEnd = chain.count - 1;
    const pRot = [0, 0, 0, 1];
    const cRot = [0, 0, 0, 1];
    const ikEffe = [0, 0, 0];
    const ikPole = [0, 0, 0];
    const dir = [0, 0, 0];
    const rot = [0, 0, 0, 1];
    const tmp = [0, 0, 0, 1];
    let lnk = chain.first();
    let t;
    if (lnk.pidx != -1)
      pose.getWorldRotation(lnk.pidx, pRot);
    else
      copy(pRot, pose.offset.rot);
    for (let i = 0; i <= iEnd; i++) {
      t = i / iEnd;
      lnk = chain.links[i];
      lerp(ikEffe, this.startEffectorDir, this.endEffectorDir, t);
      lerp(ikPole, this.startPoleDir, this.endPoleDir, t);
      mul$1(cRot, pRot, lnk.bind.rot);
      transformQuat(dir, lnk.effectorDir, cRot);
      rotationTo(rot, dir, ikEffe);
      mul$1(cRot, rot, cRot);
      transformQuat(dir, lnk.poleDir, cRot);
      rotationTo(rot, dir, ikPole);
      mul$1(cRot, rot, cRot);
      copy(tmp, cRot);
      QuatUtil.pmulInvert(cRot, cRot, pRot);
      pose.setLocalRot(lnk.idx, cRot);
      if (i != iEnd)
        copy(pRot, tmp);
    }
  }
  ikDataFromPose(chain, pose, out) {
    const dir = [0, 0, 0];
    let lnk;
    let b;
    lnk = chain.first();
    b = pose.bones[lnk.idx];
    transformQuat(dir, lnk.effectorDir, b.world.rot);
    normalize$2(out.startEffectorDir, dir);
    transformQuat(dir, lnk.poleDir, b.world.rot);
    normalize$2(out.startPoleDir, dir);
    lnk = chain.last();
    b = pose.bones[lnk.idx];
    transformQuat(dir, lnk.effectorDir, b.world.rot);
    normalize$2(out.endEffectorDir, dir);
    transformQuat(dir, lnk.poleDir, b.world.rot);
    normalize$2(out.endPoleDir, dir);
  }
}
class BipedRig extends IKRig {
  constructor() {
    super();
    __publicField(this, "hip");
    __publicField(this, "spine");
    __publicField(this, "neck");
    __publicField(this, "head");
    __publicField(this, "armL");
    __publicField(this, "armR");
    __publicField(this, "legL");
    __publicField(this, "legR");
    __publicField(this, "handL");
    __publicField(this, "handR");
    __publicField(this, "footL");
    __publicField(this, "footR");
  }
  autoRig(arm) {
    const map = new BoneMap(arm);
    let isComplete = true;
    let b;
    let bi;
    let n;
    const names = [];
    const chains = [
      { n: "hip", ch: ["hip"] },
      { n: "spine", ch: ["spine"] },
      { n: "legL", ch: ["thigh_l", "shin_l"] },
      { n: "legR", ch: ["thigh_r", "shin_r"] },
      { n: "armL", ch: ["upperarm_l", "forearm_l"] },
      { n: "armR", ch: ["upperarm_r", "forearm_r"] },
      { n: "neck", ch: ["neck"] },
      { n: "head", ch: ["head"] },
      { n: "handL", ch: ["hand_l"] },
      { n: "handR", ch: ["hand_r"] },
      { n: "footL", ch: ["foot_l"] },
      { n: "footR", ch: ["foot_r"] }
    ];
    const self = this;
    for (const itm of chains) {
      n = itm.n;
      names.length = 0;
      for (let i = 0; i < itm.ch.length; i++) {
        b = map.bones.get(itm.ch[i]);
        if (!b) {
          console.log("AutoRig - Missing ", itm.ch[i]);
          isComplete = false;
          break;
        }
        if (b instanceof BoneInfo)
          names.push(b.name);
        else if (b instanceof BoneChain)
          for (bi of b.items)
            names.push(bi.name);
      }
      self[n] = this.add(arm, n, names);
    }
    this._setAltDirection(arm);
    return isComplete;
  }
  useSolversForRetarget(pose) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    (_a = this.hip) == null ? void 0 : _a.setSolver(new HipSolver().initData(pose, this.hip));
    (_b = this.head) == null ? void 0 : _b.setSolver(new SwingTwistSolver().initData(pose, this.head));
    (_c = this.armL) == null ? void 0 : _c.setSolver(new LimbSolver().initData(pose, this.armL));
    (_d = this.armR) == null ? void 0 : _d.setSolver(new LimbSolver().initData(pose, this.armR));
    (_e = this.legL) == null ? void 0 : _e.setSolver(new LimbSolver().initData(pose, this.legL));
    (_f = this.legR) == null ? void 0 : _f.setSolver(new LimbSolver().initData(pose, this.legR));
    (_g = this.footL) == null ? void 0 : _g.setSolver(new SwingTwistSolver().initData(pose, this.footL));
    (_h = this.footR) == null ? void 0 : _h.setSolver(new SwingTwistSolver().initData(pose, this.footR));
    (_i = this.handL) == null ? void 0 : _i.setSolver(new SwingTwistSolver().initData(pose, this.handL));
    (_j = this.handR) == null ? void 0 : _j.setSolver(new SwingTwistSolver().initData(pose, this.handR));
    (_k = this.spine) == null ? void 0 : _k.setSolver(new SwingTwistEndsSolver().initData(pose, this.spine));
    return this;
  }
  useSolversForFBIK(pose) {
    return this;
  }
  bindPose(pose) {
    super.bindPose(pose);
    this._setAltDirection(pose);
    return this;
  }
  _setAltDirection(pose) {
    const FWD = [0, 0, 1];
    const UP = [0, 1, 0];
    const DN = [0, -1, 0];
    const R = [-1, 0, 0];
    const L = [1, 0, 0];
    const BAK = [0, 0, -1];
    if (this.hip)
      this.hip.bindAltDirections(pose, FWD, UP);
    if (this.spine)
      this.spine.bindAltDirections(pose, UP, FWD);
    if (this.neck)
      this.neck.bindAltDirections(pose, FWD, UP);
    if (this.head)
      this.head.bindAltDirections(pose, FWD, UP);
    if (this.legL)
      this.legL.bindAltDirections(pose, DN, FWD);
    if (this.legR)
      this.legR.bindAltDirections(pose, DN, FWD);
    if (this.footL)
      this.footL.bindAltDirections(pose, FWD, UP);
    if (this.footR)
      this.footR.bindAltDirections(pose, FWD, UP);
    if (this.armL)
      this.armL.bindAltDirections(pose, L, BAK);
    if (this.armR)
      this.armR.bindAltDirections(pose, R, BAK);
    if (this.handL)
      this.handL.bindAltDirections(pose, L, BAK);
    if (this.handR)
      this.handR.bindAltDirections(pose, R, BAK);
  }
  resolveToPose(pose, debug) {
    let ch;
    for (ch of this.items.values()) {
      if (ch.solver)
        ch.resolveToPose(pose, debug);
    }
  }
}
class DirScale {
  constructor() {
    __publicField(this, "lenScale", 1);
    __publicField(this, "effectorDir", [0, 0, 0]);
    __publicField(this, "poleDir", [0, 0, 0]);
  }
  copy(v) {
    this.lenScale = v.lenScale;
    copy$2(this.effectorDir, v.effectorDir);
    copy$2(this.poleDir, v.poleDir);
  }
  clone() {
    const c = new DirScale();
    c.copy(this);
    return c;
  }
}
class Dir {
  constructor() {
    __publicField(this, "effectorDir", [0, 0, 0]);
    __publicField(this, "poleDir", [0, 0, 0]);
  }
  copy(v) {
    copy$2(this.effectorDir, v.effectorDir);
    copy$2(this.poleDir, v.poleDir);
  }
}
class DirEnds {
  constructor() {
    __publicField(this, "startEffectorDir", [0, 0, 0]);
    __publicField(this, "startPoleDir", [0, 0, 0]);
    __publicField(this, "endEffectorDir", [0, 0, 0]);
    __publicField(this, "endPoleDir", [0, 0, 0]);
  }
  copy(v) {
    copy$2(this.startEffectorDir, v.startEffectorDir);
    copy$2(this.startPoleDir, v.startPoleDir);
    copy$2(this.endEffectorDir, v.endEffectorDir);
    copy$2(this.endPoleDir, v.endPoleDir);
  }
}
class Hip {
  constructor() {
    __publicField(this, "effectorDir", [0, 0, 0]);
    __publicField(this, "poleDir", [0, 0, 0]);
    __publicField(this, "pos", [0, 0, 0]);
    __publicField(this, "bindHeight", 1);
    __publicField(this, "isAbsolute", false);
  }
  copy(v) {
    this.bindHeight = v.bindHeight;
    this.isAbsolute = v.isAbsolute;
    copy$2(this.effectorDir, v.effectorDir);
    copy$2(this.poleDir, v.poleDir);
    copy$2(this.pos, v.pos);
  }
}
var IKData = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  DirScale,
  Dir,
  DirEnds,
  Hip
});
class BipedIKPose {
  constructor() {
    __publicField(this, "hip", new Hip());
    __publicField(this, "spine", new DirEnds());
    __publicField(this, "head", new Dir());
    __publicField(this, "armL", new DirScale());
    __publicField(this, "armR", new DirScale());
    __publicField(this, "legL", new DirScale());
    __publicField(this, "legR", new DirScale());
    __publicField(this, "handL", new Dir());
    __publicField(this, "handR", new Dir());
    __publicField(this, "footL", new Dir());
    __publicField(this, "footR", new Dir());
  }
  computeFromRigPose(r, pose) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    (_a = r.legL) == null ? void 0 : _a.solver.ikDataFromPose(r.legL, pose, this.legL);
    (_b = r.legR) == null ? void 0 : _b.solver.ikDataFromPose(r.legR, pose, this.legR);
    (_c = r.armR) == null ? void 0 : _c.solver.ikDataFromPose(r.armR, pose, this.armR);
    (_d = r.armL) == null ? void 0 : _d.solver.ikDataFromPose(r.armL, pose, this.armL);
    (_e = r.footL) == null ? void 0 : _e.solver.ikDataFromPose(r.footL, pose, this.footL);
    (_f = r.footR) == null ? void 0 : _f.solver.ikDataFromPose(r.footR, pose, this.footR);
    (_g = r.handR) == null ? void 0 : _g.solver.ikDataFromPose(r.handR, pose, this.handR);
    (_h = r.handR) == null ? void 0 : _h.solver.ikDataFromPose(r.handL, pose, this.handL);
    (_i = r.head) == null ? void 0 : _i.solver.ikDataFromPose(r.head, pose, this.head);
    (_j = r.spine) == null ? void 0 : _j.solver.ikDataFromPose(r.spine, pose, this.spine);
    (_k = r.hip) == null ? void 0 : _k.solver.ikDataFromPose(r.hip, pose, this.hip);
  }
  applyToRig(r) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    (_a = r.legL) == null ? void 0 : _a.solver.setTargetDir(this.legL.effectorDir, this.legL.poleDir, this.legL.lenScale);
    (_b = r.legR) == null ? void 0 : _b.solver.setTargetDir(this.legR.effectorDir, this.legR.poleDir, this.legR.lenScale);
    (_c = r.armL) == null ? void 0 : _c.solver.setTargetDir(this.armL.effectorDir, this.armL.poleDir, this.armL.lenScale);
    (_d = r.armR) == null ? void 0 : _d.solver.setTargetDir(this.armR.effectorDir, this.armR.poleDir, this.armR.lenScale);
    (_e = r.footL) == null ? void 0 : _e.solver.setTargetDir(this.footL.effectorDir, this.footL.poleDir);
    (_f = r.footR) == null ? void 0 : _f.solver.setTargetDir(this.footR.effectorDir, this.footR.poleDir);
    (_g = r.handL) == null ? void 0 : _g.solver.setTargetDir(this.handL.effectorDir, this.handL.poleDir);
    (_h = r.handR) == null ? void 0 : _h.solver.setTargetDir(this.handR.effectorDir, this.handR.poleDir);
    (_i = r.head) == null ? void 0 : _i.solver.setTargetDir(this.head.effectorDir, this.head.poleDir);
    (_j = r.hip) == null ? void 0 : _j.solver.setTargetDir(this.hip.effectorDir, this.hip.poleDir).setMovePos(this.hip.pos, this.hip.isAbsolute, this.hip.bindHeight);
    (_k = r.spine) == null ? void 0 : _k.solver.setStartDir(this.spine.startEffectorDir, this.spine.startPoleDir).setEndDir(this.spine.endEffectorDir, this.spine.endPoleDir);
  }
  copy(r) {
    this.hip.copy(r.hip);
    this.spine.copy(r.spine);
    this.head.copy(r.head);
    this.armL.copy(r.armL);
    this.armR.copy(r.armR);
    this.legL.copy(r.legL);
    this.legR.copy(r.legR);
    this.handL.copy(r.handL);
    this.handR.copy(r.handR);
    this.footL.copy(r.footL);
    this.footR.copy(r.footR);
    return this;
  }
}
export { Accessor, Animator, Armature, BipedIKPose, BipedRig, Bone, BoneSpring, Clip, DualQuatUtil, Gltf2, HipSolver, IKChain, IKData, IKLink, IKRig, LimbSolver, Mat4Util, Maths, Pose$1 as Pose, QuatUtil, Retarget, SkinDQ, SkinDQT, SkinMTX, SwingTwistEndsSolver, SwingTwistSolver, Transform, Vec3Util, Vec4Util };
